---
style: summer

tags:
  - c++
  - 剑指offer
  - algorithm
  - 算法
  - interview
  - 面试
---


## 剑指offer

1. 自行设计C风格字符串类的赋值号重载函数
	* 返回自身引用(**\*this**)
	* 传入参数为常引用(拷贝构造函数也有这种要求，不然会有**编译错误！**)
	* 释放原有内存(**释放内存之前必须检测指针是否为空！**)
	* 使用基于swap的方法实现赋值，新构造的tmp对象被this接管，而原this指向的对象赋给tmp，tmp被销毁时，也顺带销毁了之前this指向的对象。
	* 判断是否为同一个对象(**用对象的地址是否相等判断**)
2. singleton
	* 将构造函数、拷贝构造函数、赋值函数、析构函数作为private隐藏，类的外部无法构造新的对象。
	* 唯一的对象是类的static成员。
	* 对外只提供一个static方法`create_instance()`用于构造对象，这个方法可以设计为lazy和eager两种形式。
		* lazy方式: 只有显式调用`create_instance()`时才构造对象，之前对象一直是NULL。
		* eager方式：先构造对象，之后调用`create_instance()`时只返回构造出来的对象。
	* 注意**线程安全！**

3. 寻找数组中的重复元素
	* 简单方法是排序然后找前后相等的元素
	* 通过统一的映射规则（相等）将数组元素映射到数组的index上，然后查看是否有碰撞。**模拟hash table的碰撞场景**。
	* 检测重复和检测missing是一样的思路！
	* 如果不允许改变数组，可以另外申请一个hash table，也可以使用二分法求解。
4. 矩阵查找
	1. 将一维数组砍断堆叠
		* 一维BS + index映射
	2. 每行有序，每列也有序，但是按行或按列遍历都不一定有序
		* 每次选择角上（右上角和左下角）的元素进行分割，
		* 运用行有序且列有序的性质，每次比较可以排除一行或者一列（左上角和右下角区）
		* 关键是以单元格为原点，沿行和列方向划分空间，可以看出每次比较可以排除一个象限
		* 从角上开始时，初始只有3个象限，因此轻易地排除一个象限，不断迭代可以就可以找出答案。
5. 字符串空格替换
	* TP，先将字符串扩容到应该有的长度，从后向前移动每个字符并实现替换。
6. 反向输出链表
	* 可以更改数据，直接头插法链表逆序，然后输出
	* 不能更改数据使用栈或者递归求解
7. 根据前序(或后序)遍历和中序遍历结果重建二叉树
	* 递归：先序遍历的第一个元素是根，后序遍历的最后一个数是根，在中序中找根，按节点个数划分左右子树，递归处理子树。
8. 中序遍历的后一个节点
	* 分类要清晰
		* 有右子: 返回右子树最左的节点
		* 无右子: 向上回溯找到第一个节点时父节点左节点的节点，返回改节点的父节点
9. 双栈实现队列，双队列实现栈
10. 斐波那契数列
1. 旋转数组查找：
	* 主要性质：旋转后数组分为两个递增数组，且前半段递增数组的最小值大于后半段递增数组的最大值。
	* 查找旋转数组的最小值： BS，比较标准：`if (nums[mid] >= nums[0]) low = mid + 1`
	* 查找指定`target`：BS先根据`nums[mid]`和`nums[low]`的关系判定`nums[mid]`是处于前半段还是后半段
		* 处于前半段：若`target`在`[low, mid)`区间，`high = mid - 1`；反之，`low = mid + 1`。
		* 处于后半段：如`target`在`(mid, high]`区间，`low = mid + 1`； 反之，`high = mid - 1`。
		
2. 字符矩阵中找字符串的路径
	* 每个元素作为起点进行DFS，状态需要回溯
3. 机器人能够到达的位置
	* Leetcode Maze，将不可通过单元格为`'X'`，可通过单元格为空字符`' '`，从起点开始DFS，访问之后将单元格记为`'0'`，状态不需要回溯，DFS结束后统计`'0'`的个数即可。
4. **割绳子**
	* dp
		* 递推公式是:$dp[i]=\max_{j = 1}^{i/2}{dp[j] * dp[i - j]}$
		* 注意初始化为:$dp[0] = 0,dp[1] = 1, dp[2] = 2, dp[3]=3$

	* ~~贪心算法(**还是不太明白！！！**)~~
		* 绳子长度 $l>4$时，每次割下3，剩下的保留 
5. 数的二进制表示中有多少个1
	* 原数逐位右移
		* 若原数为负数，右移时符号位要保持为1，多次右移后，会进入死循环！
	* 1逐位左移，这个方式是正确的
	* 原数和原数减一相与，看能进行多少次这种操作！
		* `x &= x-1`作为一个基本操作，无论x的正负，x都会逐渐收敛到0.
6. double power
	* 使用位运算
	* exponent的每一位的权重都是前一位对应权重的2次幂
7. 顺序打印从1到n位最大整数
	* 大数使用字符串表示
	* dfs：所有数都表示为等长的字符串，每次递归遍历10个子问题（该位有10中情况），解空间树是一个很规整的10叉树，需要回溯。
	* 打印字符串时，要去掉首部的零，如果全零就输出0。
8. O(1)时间复杂度内删除节点
	* 直接将后一个节点的值拿来覆盖当前节点
	* 节点为最后一个时遍历找pre节点。
	* 时间复杂度按概率来算仍然是O(1)
9. 正则表达式:只考虑`*`和`.`
	* DP
	* 初始化:`dp[0][0] = true`，母串为空，模式串不为空的情况
	* 匹配任意的`s[i]`和`p[j]`：
		1. `p[j] == '*'`：首先要满足`j > 1`，然后分重复与不重复两种情况：
			* 不重复时取决于:`dp[i][j - 2]`
			* 重复时取决于:`p`的请前一个字符为`.`或者`p`的前一个字符与`s`的当前字符相同，而且`dp[i - 1][j] == true`
		2. 不是上一种情况：两个对应字符相同，或者`p[j] == '.'`
0. valid number
	* 直接上正则表达式，
	* `regex e("^([\\+\\-])?((\\d+(\\.\\d*)?)|(\\.\\d+))(e([\\+\\-]?\\d+))?$")`
	* `return regex_match(s.begin(), s.end(), e);`
1. 按规则（如负数在前，正数在后）分离数组
	* TP
	* 使用函数指针或函数对象（在类中重载`()`操作符）作为rule，将关键行为剥离
2. 链表的第K个节点
	* TP
	* 注意边界(NULL、K过大、K过小等)
3. 链表成环检测即环入口
	* TP: 快指针走两步，慢指针走一步，直到两者相遇。慢指针从头走，两指针一次走一步，直到两者相遇，相遇点就是环起点。
4. 反转链表
	* 链表头插法
5. 合并两个有序链表
	* TP
6. ~~树的子结构~~
	* 2重递归
7. ~~二叉树镜像~~
	* 递归
8. 对称二叉树
	* 递归
	* 根节点的左右子树对称，就是说左子树的右子树与右子树的左子树对称，左子树的左子树和右子树的右子树对称。
9. 顺时针打印矩阵
	* Leetcode 54，每次输出起点为`(i, i)`可以退出每圈遍历的每个方向的起点和终点。
	* 两个方向的遍历不能重复，注意去重。
0. 包含min函数的栈
	* 另存一个min栈存储当前最小值，如果新入栈元素`<=`min栈栈顶时都要对min栈进行push操作
1. 栈的入栈出栈序列
	* DFS
	* 维护栈的状态和出入栈序列的位置
2. 二叉树层序遍历
	* 基本层序遍历（双queue）
	* 之字层序遍历（双stack,奇数层先入左子再入右子，偶数层先入右子再入左子）
3. 二叉树后序遍历
	* 非递归方法
		a. 先定义新的数据结构，记录右子是否访问过
		b. 每次先把所有左子入栈
		c. 如果栈顶右子访问过或为空，出栈并访问
		d. c中条件不满足，则重复b 
4. 和为某个值的path
	* dfs
	* 维护当前节点的sum和path，到达叶子节点进行判断
5. ~~复杂链表复制~~
	* hashmap
	* 如果已经被复制过，将指针指向复制得到的新节点
	* 没复制过，复制
	* 变式题：树的复制，递归复制，HashMap记录原节点和复制生成节点的映射
6. BST转为双向链表
	* dfs
	* ~~链表尾部注意使用双层指针！因为复制原变量之后在子程序中修改是无效的！~~
7. 序列化与解序列化二叉树
	* 递归，使用istringstream和ostringstream（从stream读取字符串的时候默认以空格截断）
	* 利用先序遍历的方式
8. 字符串排列
	* DFS，记录频率，每消耗一个字符将频率减1，注意回溯！
9. 数组中出现次数超过一半的数
	* 投票法,O(N)。
0. 最小的K个数
	* 基于partition的方法，O(N)，改变数组，不适用于海量数据（需要全部装入内存进行partition）
	* 基于堆的方式，O(NlogK)，适用于海量数据
1. 数据流中的中位数
	* 两个堆，较小的一半用大根堆，较大的一半用大根堆
	* 保证小根堆的`size >=`大根堆的`size`
2. 最大连续子数组和
	* 暴力法， O($N^2$)。
	* DP
	* 贪心算法，是DP的优化，使用O(1)的空间实现DP。
	* DP和贪心都用了相同的性质，如果前面的子数组和`< 0`，则以该子数组开始的所有子数组都不需要考虑了，因为其和一定小于除掉该子数组之后的部分的和。
3. 从1到n的序列中数字1（可以扩展到任意一个数字）出现的个数
	* 递归
	* 先把高位考虑完全，在加上低位的结果。
	* ~~需要用到排列组合的思想~~
4. 从1到无穷大的序列中第n位的数字
	* 规律题
	* 1位的10个，2位的90个，3位的900个……
5. ~~排列数组使排列得到的数最小~~
	* 定义比较规则，排序！
	* 证明解法的正确性
6. ~~将数字翻译成字符串的翻译方法数~~
	* DP
7. ~~礼物的最大值~~
	* DP
8. 最长不含重复字符的子串
	* TP，使用hashmap（`vector[256]`）记录是否有重复，无重复继续右移右指针，有重复右移指针后，左移左指针。
	* DP
9. **丑数**
	* **经典面试题**
	* 可以用堆来实现，堆实现版本有大量的冗余，空间复杂度太高，但是时间复杂度是可以接受的。
	* 直接基于数组实现，记录2，3，5等基数的index，每次从中选择乘上基数后最小的值并更新index即可，这可以是说是一种DP的思想。**注意**去重，当多个index对应值乘上基数后得到相同值，要同时更新index。
0. 字符串中第一个出现的只出现一次的字符
	* hashmap，同时记录第一次出现的位置和出现的频数。O(N)。
1. 数组中的逆序对
	* 归并排序的应用
	* merge的过程中，每次右侧先插入，`count += lr - ll`。
2. 两个链表的交点
	* TP
	* 先得出两个链表的长度差`diff`
	* 较长链表的头先走`diff`步，这时较短链表头开始走，直到两者相遇，相遇点就是交点。
3. 排序数组中查找数字
	* BS
4. ~~BST的第K大节点~~
	* 中序遍历二叉树（递归或非递归）
5. 二叉树深度/平衡二叉树
	* 平衡二叉树，使用深度变量，d<0表示树不平衡，子树不平衡，整个树一定不平衡，可以进行短路计算。
6. 数组中数字出现的次数
	* 一个出现一次，其他数字出现2次
		* 位运算/异或
	* 一个出现一次，其他出现3次
		* 位运算/统计每位的和
7. ~~和为s的序列~~
	* 和为s的两个数
		* TP
	* 和为s的连续子序列，TP，同**48**。
	* 和为s的定长序列(不需要连续)，leetcode **3/4 sum**，TP升级版，多个指针MP。
8. 字符串反转
	* 字符串单词顺序反转
		* 先将整个串反转
		* 再逐单词反转
	* 字符串旋转
		* 前一部分反转
		* 后一部分反转
		* 整体反转
		* **用左右手比划**
9. 队列最大值
	* 滑动窗口最大值
		* 维护固定窗口的递减deque
	* 实现带有max函数的queue
		* 维护递减deque，**stack with minimum**使用的是递增栈。
	* **引发思考**：递减队列，递增队列，递减栈，递增栈都有用到，分场景，具体原因是什么？为什么要用递减或递增的结构，共性在哪里？
0. ~~N个骰子的点数及概率~~
	* 递归或DP
1. ~~扑克牌中的顺子~~
	* multiset
2. ~~约瑟夫环~~
	* 原题每次沿顺时针方向删除第m个节点
	* 变式为每次先沿顺时针方向再沿逆时针方向删除第m个节点（老大的作业题）
	* ~~可以通过数学变换简化！~~
3. 倒卖股票
	* 记录之前（包括当日）的价格最小值，当日尝试卖出，更新当前最大利润
4. 求和但是不许用循环控制语句
	* 基于构造函数，利用new 对象数组时每个对象都会调用类的构造函数
	* 基于函数指针，使用双重否定判定实参是否为0。
5. 使用位运算实现加法
	* 递归
	* 每次分别计算无进位加和`sum`（用`|`）和无加和进位`c`（用`&`），递归地计算`sum`和`c`的和
	* 由于只有两个算子对应位上全为1才会有进位，而且进位`c`每次需要左移，因此`c`中的1会越来越少。
6. ~~构建乘积数组~~
	* 将待填充数组视为矩阵，两次循环算出结果。
7. ~~stoi实现~~
	* 考虑空格、正负号、溢出
8. 树中两个节点的最近公共祖先
	* 树为BST，直接递归，沿一个分支查找即可
	* 存在指向父节点的指针，两个链表的第一个公共节点
	* 普通树：
		1. 笨方法：无指向父节点的指针，找出根节点到两个节点的path，两个链表最后一个公共节点
		2. 高效方法：尝试递归地在一棵树中找两个节点，若两个节点在不同子树上，则root为解，若两者在相同子树上，递归查找该子树。若只找到一个，另一个没找到，有两种可能：
			* 一个节点是另一个节点的后代，这是root为界
			* 确实没找到，~~这种情况怎么解释？~~

	


