---
style: summer

tags:
  - c++
  - 剑指offer
  - algorithm
  - 算法
  - interview
  - 面试
---


## 剑指offer

1. 自行设计C风格字符串类的赋值号重载函数
	* 实现该函数首先有两个重要问题要考虑：
		1. `this`指向的object和`src`object是否为同一个object:使用object的地址进行判断
		2. `this`指向的object是否为空，如果不为空，`this`指向的对象该如何处理：根据处理`this`指向的原对象的处理方法分为两种实现方案:
			* 先将`this`指向的对象释放，然后重新分配内存并复制`src`的内容
			* 基于`swap`的方法实现赋值，新构造的`tmp`对象被`this`接管，而`this`原指向的对象赋给`tmp`，函数结束时，`tmp`被销毁，顺带销毁了`this`指向的对象。
	* 设计一个类首先要有**构造函数**、**拷贝构造函数**和**析构函数**。
	* `int strlen(char *str)`返回的结果是字符串中有效字符的个数，不包括表示字符串结尾的特殊字符`'\0'`。
	* `void strcpy(char *dst, const char *src)`作用是将源内存区域`src`深拷贝到目的地址`dst`，因此`dst`必须足够大，否则会导致内存错误覆盖,`dst`指向的内存区域的大小至少应该容纳`strlen(src) + 1`个字符。
	* `new`和`delete`是一对，`T* var = new T[]`和`delete[] var`是一对，`delete`之前必须检验空指针，智能指针`nullptr`应该用来全面取代`NULL`。
	* 赋值号重载函数应该返回`this`指向的对象的引用类型而不是直接返回改对象，这个过程中不应该发生复制构造函数的隐式调用。
	* 拷贝构造函数和赋值号重载函数的传入参数必须为常引用，不然会导致**编译错误！**
2. singleton
	* 将构造函数、拷贝构造函数、赋值号重载函数、析构函数作为`private`隐藏，类的外部无法构造新的对象。
	* 该类的唯一对象是类的static成员`_instance`。
	* 对外只提供一个static方法`create_instance()`用于构造对象，这个方法可以设计为lazy和eager两种形式。
		* lazy方式: 只有显式调用`create_instance()`时才构造对象，之前对象一直是NULL。
		* eager方式：先构造对象，之后调用`create_instance()`时只是返回之前构造出来的对象。
	* **线程安全**：可以创建一个`private static`object成员专门用于加锁确定同一时刻只存在一个进程在创建该类的对象。每次调用`create_instance`时，先检测`_instance`是否为空，只有为空的时候才加锁，因为该类的对象同时可以允许多个进程读，但是只能有一个进程可以写，而且只能写一次。这么加锁也是因为加锁是一个非常繁琐的过程，系统消耗极大。
3. 寻找数组中的重复元素：给定长度为$n$的数组$A$，$A$中任意元素$A_i \in [0, n-1]$，找出其中重复的元素。
	* 简单方法是排序然后找前后相等的元素，$O(N\log N)$。
	* 通过统一的映射规则（相等）将数组元素映射到数组的index上，然后查看是否有碰撞。**模拟hash table的碰撞场景**。
	* 检测重复和检测missing是一样的思路:由于数组元素的值和数组元素的index处于同样的值域，如果两者都没有重复可以成功进行一一映射，否则会有冲突。为了表现冲突，可以在遍历数组元素的过程中，将元素值改为负值，用数组元素的绝对值和数组的index进行映射。
		1. 遍历数组$A$，对于$A$中任意的元素$A_i$
			1. 如果$A[|A[i]|] < 0$，则$A[i]$重复
			3. 如果$A[|A[i]|] > 0$，则$A[i]$目前没有重复，令$A[|A[i]|]=-A[|A[i]|]$。
			4. 如果$A[|A[i]|] = 0$，记录0出现的次数$c$
		5. 遍历结束时，如果没有找到重复数字，有两种情况
			1. 重复元素为0: $c > 1$
			2. 完全没有重复元素: $c = 1$
	
		这种解法时间复杂度为$O(N)$。
	* 如果不允许改变数组，可以另外申请一个hash table，也可以使用二分法求解。
4. 矩阵查找
	1. 将一维数组砍断堆叠
		* 一维BS + index映射
	2. 每行有序，每列也有序，但是按行或按列遍历都不一定有序
		* 每次选择角上（右上角和左下角）的元素进行分割，
		* 运用行有序且列有序的性质，每次比较可以排除一行或者一列（左上角和右下角区）
		* 关键是以单元格为原点，沿行和列方向划分空间，可以看出每次比较可以排除一个象限
		* 从角上开始时，初始只有3个象限，因此轻易地排除一个象限，不断迭代可以就可以找出答案。
5. 字符串空格替换
	* TP，先将字符串扩容到应该有的长度，从后向前移动每个字符并实现替换。
6. 反向输出链表
	* 可以更改数据：直接头插法链表逆序，然后顺序输出。头插法可以借助**dummy node**，**dummy node**的作用是消除原始链表空和非空的差异。
	* 不能更改数据：使用栈或者递归求解
7. 根据前序(或后序)遍历和中序遍历结果重建
	* 递归：先序遍历的第一个元素是根，后序遍历的最后一个元素是根，在中序中找根，按节点个数划分左右子树，递归处理子树。
	* 注意base情况：遍历结果为空，或者`start > end`时返回`NULL`！
8. 中序遍历的后一个节点
	* 分类要清晰
		* 有右子: 返回右子树最左的节点
		* 无右子: 向上回溯找到第一个节点时父节点左节点的节点，返回改节点的父节点
9. 双栈实现队列，双队列实现栈
10. 斐波那契数列
1. 旋转数组查找：
	* 主要性质：旋转后数组分为两个递增数组，且前半段递增数组的最小值大于后半段递增数组的最大值。
	* 查找旋转数组的最小值： BS，比较标准：`if (nums[mid] >= nums[0]) low = mid + 1`
	* 查找指定`target`：BS先根据`nums[mid]`和`nums[low]`的关系判定`nums[mid]`是处于前半段还是后半段
		* 处于前半段：若`target`在`[low, mid)`区间，`high = mid - 1`；反之，`low = mid + 1`。
		* 处于后半段：如`target`在`(mid, high]`区间，`low = mid + 1`； 反之，`high = mid - 1`。
		
2. 字符矩阵中找字符串的路径
	* 每个元素作为起点进行DFS，状态需要回溯
3. 机器人能够到达的位置
	* Leetcode Maze，将不可通过单元格为`'X'`，可通过单元格为空字符`' '`，从起点开始DFS，访问之后将单元格记为`'0'`，状态不需要回溯，DFS结束后统计`'0'`的个数即可。
4. **割绳子**
	* dp
		* 递推公式是:$dp[i]=\max_{j = 1}^{i/2}{dp[j] * dp[i - j]}$
		* 注意初始化为:$dp[0] = 0,dp[1] = 1, dp[2] = 2, dp[3]=3$

	* 贪心算法：绳子长度 $l>4$时，每次割下3，剩下的保留，证明如下：
		1. 当`n<5`时，我们会发现，无论怎么剪切，乘积`product <= n`，n为4时，product最大为2*2=4；
		2. 当`n>=5`时，可以证明`n < 2(n-2) <= 3(n-3)`。**所以应该尽可能地多剪长度为3的绳子段**。
5. 数的二进制表示中有多少个1
	* 原数逐位右移
		* 若原数为负数，右移时符号位要保持为1，多次右移后，会进入死循环！
	* 1逐位左移，这个方式是正确的
	* 原数和原数减一相与，看能进行多少次这种操作！
		* `x &= x-1`作为一个基本操作，无论x的正负，x都会逐渐收敛到0.
6. double power
	* 使用位运算
	* exponent的每一位的权重都是前一位对应权重的2次幂
7. 顺序打印从1到n位最大整数
	* 大数使用字符串表示
	* dfs：所有数都表示为等长的字符串，每次递归遍历10个子问题（该位有10中情况），解空间树是一个很规整的10叉树，需要回溯。
	* 打印字符串时，要去掉首部的零，如果全零就输出0。
8. O(1)时间复杂度内删除节点
	* 直接将后一个节点的值拿来覆盖当前节点
	* 节点为最后一个时遍历找pre节点。
	* 时间复杂度按概率来算仍然是O(1)
9. 正则表达式:只考虑`*`和`.`
	* DP
	* 初始化:`dp[0][0] = true`，母串为空，模式串不为空的情况
	* 匹配任意的`s[i]`和`p[j]`：
		1. `p[j] == '*'`：首先要满足`j > 1`，然后分重复与不重复两种情况：
			* 不重复时取决于:`dp[i][j - 2]`
			* 重复时取决于:`p`的请前一个字符为`.`或者`p`的前一个字符与`s`的当前字符相同，而且`dp[i - 1][j] == true`
		2. 不是上一种情况：两个对应字符相同，或者`p[j] == '.'`
0. valid number
	* 直接上正则表达式，
	* `regex e("^([\\+\\-])?((\\d+(\\.\\d*)?)|(\\.\\d+))(e([\\+\\-]?\\d+))?$")`
	* `return regex_match(s.begin(), s.end(), e);`
1. 按规则（如负数在前，正数在后）分离数组
	* TP
	* 使用函数指针或函数对象（在类中重载`()`操作符）作为rule，将关键行为剥离
2. 链表的第K个节点
	* TP
	* 注意边界(NULL、K过大、K过小等)
3. 链表成环检测即环入口
	* TP: 快指针走两步，慢指针走一步，直到两者相遇。慢指针从头走，两指针一次走一步，直到两者相遇，相遇点就是环起点。
4. 反转链表
	* 链表头插法
5. 合并两个有序链表
	* TP
6. 给定两棵树`T1, T2`，判断`T2`是否为`T1`的子结构
	* 2重递归
	* 外层递归遍历`T1`的所有子树`T`
	* 内层递归检测`T2`是否为`T`的head
7. 二叉树镜像
	* 递归
	* 先交换左子和右子，在分别对左子树和右子树进行镜像操作
8. 对称二叉树
	* 递归
	* 根节点的左右子树对称，就是说左子树的右子树与右子树的左子树对称，左子树的左子树和右子树的右子树对称。
9. 顺时针打印矩阵
	* Leetcode 54，每次输出起点为`(i, i)`可以退出每圈遍历的每个方向的起点和终点。
	* 两个方向的遍历不能重复，注意去重。
0. 包含min函数的栈
	* 另存一个min栈存储当前最小值，如果新入栈元素`<=`min栈栈顶时都要对min栈进行push操作
1. 栈的入栈出栈序列
	* DFS
	* 维护栈的状态和出入栈序列的位置
2. 二叉树层序遍历
	* 基本层序遍历（双queue）
	* 之字层序遍历（双stack,奇数层先入左子再入右子，偶数层先入右子再入左子）
3. 二叉树后序遍历
	* 非递归方法
		a. 先定义新的数据结构，记录右子是否访问过
		b. 每次先把所有左子入栈
		c. 如果栈顶右子访问过或为空，出栈并访问
		d. c中条件不满足，则重复b 
4. 和为某个值的path
	* dfs
	* 维护当前节点的sum和path，到达叶子节点进行判断
5. 复杂链表复制
	* hashmap记录原指针到复制所得的指针的映射，初始化要将`NULL`映射到`NULL`。
	* 遍历链表，对于任一节点，如果自身指针及其前向、后继等指针成员所指向的节点没有被复制过，复制并记录映射
	* 修改复制所得指针，使其指向复制得到的新节点
	* 变式题：树的复制，递归复制，HashMap记录原节点和复制生成节点的映射
6. BST转为双向链表
	* 递归：先使用递归将左右子树分别转换为双向循环链表`left`和`right`，然后拼接三个双向循环链表(`left`,'right'和`root`)。
7. 序列化与解序列化二叉树
	* 递归，使用istringstream和ostringstream（从stream读取字符串的时候默认以空格截断）
	* 利用先序遍历的方式
8. 字符串排列
	* DFS，记录频率，每消耗一个字符将频率减1，注意回溯！
9. 数组中出现次数超过一半的数
	* 投票法,O(N)。
0. 最小的K个数
	* 基于partition的方法，O(N)，改变数组，不适用于海量数据（需要全部装入内存进行partition）
	* 基于堆的方式，O(NlogK)，适用于海量数据
1. 数据流中的中位数
	* 两个堆，较小的一半用大根堆，较大的一半用大根堆
	* 保证小根堆的`size >=`大根堆的`size`
2. 最大连续子数组和
	* 暴力法， O($N^2$)。
	* DP
	* 贪心算法，是DP的优化，使用O(1)的空间实现DP。
	* DP和贪心都用了相同的性质，如果前面的子数组和`< 0`，则以该子数组开始的所有子数组都不需要考虑了，因为其和一定小于除掉该子数组之后的部分的和。
3. 从1到n的序列中数字1（可以是`[0, 9]`任意一个数字）出现的个数
	* 递归，先解决序列中更大的数，递归求解较小的数的结果的结果，加和就是最终结果
	* 需要用到排列组合的思想
	* 以`f(12035)`举例：
		1. 先计数`[2036, 12035]`，万位的`1`出现个数为`2026`次，其他位上的`1`的出现次数可以这么考虑：不考虑万位，其他位的数相当于遍历了`[0000, 9999]`，令任意一位为`1`，其余位可以任取`[0, 9]`10个数字中的一个，因此总计有`10^3`种情况
		2. 同理可以计算`f(2035)`
		3. 以上两步的加和就是最终结果
4. 从1到无穷大的序列中第n位的数字
	* 规律题
	* 1位的10个，2位的90个，3位的900个……
5. 排列数组使排列得到的数最小
	* 定义比较规则：`m`和`n`两个数，有两种拼接方式`mn`和`nm`，有可能形成大数问题，因此应该用字符串表示。`mn`和`nm`的大小，反映了`m`和`n`的前后顺序。
	* 排序
	* 证明解法的正确性，可以证明上面的比较规则满足自反性、对称性和传递性，用反证法可以证明排序之后的结果就是最终结果
6. 将数字翻译成字符串的翻译方法数
	* DP：`dp[0] = 1`，表示空串只有1种翻译方式。`dp[n] += dp[n - 1]` 如果`s[n]`可以翻译为一个字符; `dp[n] += dp[n - 2]`如果`s[n - 1]`和`s[n]`组成的字符串能够翻译成一个字符。
7. 礼物的最大值
	* DP：子问题有两个即可以有左边或者上边的单元格导到当前的单元格，因此`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`。
8. 最长不含重复字符的子串
	* TP，使用hashmap（`vector[256]`）记录是否有重复，无重复继续右移右指针，有重复右移指针后，左移左指针。
	* DP
9. **丑数**
	* **经典面试题**
	* 可以用堆来实现，堆实现版本有大量的冗余，空间复杂度太高，但是时间复杂度是可以接受的。
	* 直接基于数组实现，记录2，3，5等基数的index，每次从中选择乘上基数后最小的值并更新index即可，这可以是说是一种DP的思想。**注意**去重，当多个index对应值乘上基数后得到相同值，要同时更新index。
0. 字符串中第一个出现的只出现一次的字符
	* hashmap，同时记录第一次出现的位置和出现的频数。O(N)。
1. 数组中的逆序对
	* 归并排序的应用
	* merge的过程中，每次右侧先插入，`count += lr - ll`。
2. 两个链表的交点
	* TP
	* 先得出两个链表的长度差`diff`
	* 较长链表的头先走`diff`步，这时较短链表头开始走，直到两者相遇，相遇点就是交点。
3. 排序数组中查找数字
	* BS
4. BST的第K大节点
	* 中序遍历二叉树（递归或非递归）
	* 递归：递归过程中用引用型变量`res`和`k`分别记录当前结果和新的`k`，每遍历一个节点`k--`，`k == 0`返回要遍历的节点。
	* 非递归的方法和递归方法类似，没访问过一个节点`k--`，`k == 0`时返回当前节点。
5. 二叉树深度/平衡二叉树
	* 平衡二叉树，使用深度变量，d<0表示树不平衡，子树不平衡，整个树一定不平衡，可以进行短路计算。
6. 数组中数字出现的次数
	* 一个出现一次，其他数字出现2次
		* 位运算/异或
	* 一个出现一次，其他出现3次
		* 位运算/统计每位的和
7. 和为s的序列
	* 和为s的两个数
		* TP
	* 和为s的连续子序列，TP，同**48**。
	* 和为s的定长序列(不需要连续)，leetcode **3/4 sum**，TP升级版，多个指针MP。
8. 字符串反转
	* 字符串单词顺序反转
		* 先将整个串反转
		* 再逐单词反转
	* 字符串旋转
		* 前一部分反转
		* 后一部分反转
		* 整体反转
		* **用左右手比划**
9. 队列最大值
	* 滑动窗口最大值
		* 维护固定窗口的递减deque
	* 实现带有max函数的queue
		* 维护递减deque，**stack with minimum**使用的是递增栈。
	* **引发思考**：递减队列，递增队列，递减栈，递增栈都有用到，分场景，具体原因是什么？为什么要用递减或递增的结构，共性在哪里？
0. N个骰子的点数及概率
	* DP
	* 欲知N个骰子的点数之和出现概率，可以利用N-1个骰子的点数之和出现的概率
	* 假设已知N-1个骰子的点数之和出现的频数为范围为`[0, N * 6]`，相应的频数为`[y1, ……, yn]`， 则N个骰子的点数之和出现的频数可以这么计算：对于任意一个可能的点数之和`x`,先令`dp[x] = 0`，然后令新加入的骰子`i`的点数从6变到1，如果剩下的所有骰子的点数之和大于等于0，`dp[x] += dp[i]`
1. 扑克牌中的顺子
	* TP
	* 大小王视为0，记录其他数字的间隔，间隔数大于0的个数那就没救了，有重复也没救了！
2. 约瑟夫环
	* 原题每次沿顺时针方向删除第m个节点
	* 变式为每次先沿顺时针方向删除第k个节点，再沿逆时针方向删除第m个节点，如此迭代，直到环中只剩下一个节点，输出该节点。
	* 原题的数学推导：
		1. `f(n, m) = f(n - , m)`
		2. 一开始从index为0的节点开始删除，原始问题为`f(n, m)`，假设第一个删除的节点的index为`k = (m - 1) % n`, 删除之后序列的index变为`[0, 1, ..., k - 1, k + 1, ..., n -1]`
		3. 下一次删除的起点为`k + 1`，序列原始index为`[k + 1, k + 2, ..., n - 1, 0, 1, ..., k - 1]`，通过映射`p = (x - k - ) % n`(p的反函数为`p = (x + k + 1) % n`)， 可以将剩余序列的index依次变换为`[0, 1, ..., n - 2]`，此时问题变为`f(n - 1, m)`
		4. 根据1、2、3步可以得出：
			* 当 `n = 1`时， `f(n, m) = 0`
			* 当 `n > 1`时， `f(n, m) = [f(n - 1, m) + m] % n`
3. 倒卖股票
	* 记录之前（包括当日）的价格最小值，当日尝试卖出，更新当前最大利润
4. 求和但是不许用循环控制语句
	* 基于构造函数，利用new 对象数组时每个对象都会调用类的构造函数
	* 基于函数指针，使用双重否定判定实参是否为0。
5. 使用位运算实现加法
	* 递归
	* 每次分别计算无进位加和`sum`（用`|`）和无加和进位`c`（用`&`），递归地计算`sum`和`c`的和
	* 由于只有两个算子对应位上全为1才会有进位，而且进位`c`每次需要左移，因此`c`中的1会越来越少。
6. 构建乘积数组：已知数组$A=[A_1, A_2, ..., A_{n-1}]$，生成数组$B=[B_1, B_2, ..., B_{n-1}]$，要求$B_i = \frac{\prod_{i = 0}^{n-1}A_i}{A_i}$且不能**通过除法实现**。
	* 方法一：
		* 将待填充数组视为填充矩阵，两层循环算出结果，$O(N_2)$。
		* 填充矩阵的规则为
			1. $M_{i,j}=A_j,i\neq{j}$
			2. $M_{i,j}=1,i=j$
		* 将按照上述规则填充得到的矩阵的每一行（第`i`行）乘起来就是$B_i$
		* 可以使用一维数组简化存储
	* 方法二：运用类似DP的思想可以简化第一种方法。对于每一行(第`i`行)，先把左边`[0, i)`的乘上，这时可以利用上一行的结果（DP的思想），再把右边`(i, n-1]`的乘上。乘左边和乘右边各需要一层循环，$O(N)$。
7. stoi实现
	* 考虑空格、正负号、溢出
	* 首先去掉首尾的空白字符
	* 如果第一个字符是`-`，则符号位负，其余情况视为正
	* 如果遍历过程中出现了非数字字符，则退出并报错
	* 按照进位的方法，将之前结果乘上10加上本次转换得到的结果
	* 综合之前的结果和本次转换的一位结果还有正负号，与`INT_MAX`或者`INT_MIN`比较，判断溢出
8. 树中两个节点的最近公共祖先
	* 树为BST，直接递归，沿一个分支查找即可
	* 存在指向父节点的指针，两个链表的第一个公共节点
	* 普通树：
		1. 笨方法：无指向父节点的指针，找出根节点到两个节点的path，两个链表最后一个公共节点
		2. 高效方法：同时在一棵二叉树中查找p和q两个节点，如果只找到了p节点则返回1，如果只找到了q节点，则返回2，如果同时找到p和q节点，则返回3，其余情况返回0，那么根据返回值就可以判断该节点是否为LCA


	


