---
style: summer

tags:
  - c++
  - 剑指offer
  - algorithm
  - 算法
  - interview
  - 面试
---


## 剑指offer

1. 自行设计C风格字符串类的赋值号重载函数
	* 返回自身引用(**\*this**)
	* 传入参数为常引用(拷贝构造函数也有这种要求，不然会有**编译错误！**)
	* 释放原有内存(**释放内存之前必须检测指针是否为空！**)
	* 判断是否为同一个对象(**用对象的地址是否相等判断**)
2. singleton
	* 将构造函数、拷贝构造函数、赋值函数、析构函数隐藏，使用static关键字。注意区分线程安全。

3. 寻找数组中的重复元素
	* 简单方法是排序然后找前后相等的元素
	* 通过统一的映射规则（相等）将数组元素映射到数组的index上，然后查看是否有碰撞。**模拟hash table的碰撞场景**。
	* 检测重复和检测missing是一样的思路！
	* 如果不允许改变数组，可以另外申请一个hash table，也可以使用二分法求解。
4. 矩阵查找
	1. 将一维数组砍断堆叠
		* 一维BS + index映射
	2. 非第一种情况
		* 每次选择角上的元素进行分割，每次可以排除一行或者一列
5. 字符串空格替换
	* TP，先将字符串扩容到应该有的长度，从后向前移动每个字符并实现替换。
6. 反向输出链表
	* 可以更改数据，直接头插法链表逆序，然后输出
	* 不能更改数据使用栈或者递归求解
7. 根据前序(或后序)遍历和中序遍历结果重建二叉树
	* 递归
8. 中序遍历的后一个节点
	* 分类要清晰
		* 有右子: 返回右子树最左的节点
		* 无右子: 向上回溯找到第一个节点时父节点左节点的节点，返回改节点的父节点
9. 双栈实现队列，双队列实现栈
10. 斐波那契数列
1. 旋转数组找最小值
	* BS。
	* 比较标准：`if (nums[mid] >= nums[0]) low = mid + 1`
	* 因为旋转后数组分为两个递增数组
2. 字符矩阵中找字符串的路径
	* 每个元素作为起点进行DFS，状态需要回溯
3. 机器人能够到达的位置
	* 将不可通过元素设为'X'，转为Maze。
4. **割绳子**
	* dp
		* 递推公式是:$dp[i]=\max_{j = 1}^{i/2}{dp[j] * dp[i - j]}$
		* 注意初始化为:$dp[0] = 0,dp[1] = 1, dp[2] = 2, dp[3]=3$

	* 贪心算法(**还是不太明白！！！**)
		* 绳子长度 $l>4$时，每次割下3，剩下的保留 
5. 数的二进制表示中有多少个1
	* 原数逐位右移
		* 若原数为负数，右移时符号位要保持为1，多次右移后，会进入死循环！
	* 1逐位左移，这个方式是正确的
	* 原数和原数减一相与，看能进行多少次这种操作！
		* **这个方法实在是太骚了！**
		* $x &= x-1$作为一个基本操作，无论x的正负，x都会逐渐收敛到0.
6. double power
	* 使用位运算
	* exponent的每一位的权重都是前一位对应权重的2次幂
7. 顺序打印从1到n位最大整数
	* dfs
	* 大树使用字符串处理
8. O(1)时间复杂度内删除节点
	* 直接将后一个节点的值拿来覆盖当前节点
	* 节点为最后一个时遍历找pre节点。
	* 时间复杂度按概率来算仍然是O(1)
9. 正则表达式
	* DP
	* 注意初始化
0. valid number
	* 直接上正则表达式
1. 按规则（如负数在前，正数在吼）分离数组
	* TP
	* 使用函数指针或函数对象作为rule，将关键行为剥离
2. 链表的第K个节点
	* TP
	* 注意边界(NULL、K过大、K过小等)
3. 链表成环检测即环入口
	* TP
4. 反转链表
	* 链表头插法
5. 合并两个有序链表
	* TP
6. 树的子结构
	* 2重递归
7. 二叉树镜像
	* 递归
8. 对称二叉树
	* 递归
9. 顺时针打印矩阵
	* 腾讯OMG面试题
0. 包含min函数的栈
	* 另存一个栈存储当前最小值，当且仅当被覆盖的时候才push
1. 栈的入栈出栈序列
	* DFS
	* 维护栈的状态和出入栈序列的位置就好
2. 二叉树层序遍历
	* 基本层序遍历（双queue）
	* 之字层序遍历（双stack,奇数层先入左子再入右子，偶数层先入右子再入左子）
3. 二叉树后序遍历
	* 非递归方法
		a. 先定义新的数据结构，记录右子是否访问过
		b. 每次先把所有左子入栈
		c. 如果栈顶右子访问过或为空，出栈并访问
		d. c中条件不满足，则重复b 
4. 和位某个值的path
	* dfs
	* 维护当前节点的sum和path，到达叶子节点进行判断
5. 复杂链表复制
	* hashmap
	* 如果已经被复制过，将指针指向复制得到的新节点
	* 没复制过，复制
6. BST和双向链表
	* dfs
	* 链表尾部注意使用双层指针！因为复制原变量之后在子程序中修改是无效的！
7. 序列化与解序列化二叉树
	* 使用istringstream和ostringstream（从stream读取字符串的时候默认以空格截断）
	* 利用先序遍历的方式
8. 字符串排列
	* DFS
		* 记录频率，每消耗一个字符将频率减1，注意回溯！
9. 数组中出现次数超过一半的数
	* 投票法,O(N)。
0. 最小的K个数
	* 基于partition的方法，O(N)，改变数组，不适用于海量数据（需要全部装入内存进行partition）
	* 基于堆的方式，O(NlogK)，适用于海量数据
1. 数据流中的中位数
	* 两个堆，较小的一半用大根堆，较大的一半用大根堆
	* 逻辑整清晰！
2. 最大子数组和
	* BF， O($N^2$)。
	* DP
	* 贪心算法，是DP的优化，使用O(1)的空间实现DP。
	* DP和贪心都用了相同的性质，如果前面的子数组和为0，则以该子数组开始的所有子数组都不需要考虑了，因为其和一定小于除掉该子数组之后的部分的和。
3. 从1到n的序列中数字1出现的个数
	* 递归
	* 先把高位考虑完全，在加上低位的结果。
	* 需要用到排列组合的思想
4. 从1到无穷大的序列中第n位的数字
	* 规律题
	* 1位的10个，2位的90个，3位的900个……
5. 排列数组使排列得到的数最小
	* 定义比较规则，排序！
	* 证明解法的正确性
6. 将数字翻译成字符串的翻译方法数
	* DP
7. 礼物的最大值
	* DP
8. 最长不含重复字符的子串
	* TP，使用hashmap记录是否有重复，无重复继续右移右指针，有重复右移指针后，左移左指针。
	* DP
9. **丑数**
	* 微软小冰组经典面试题
	* 可以用堆来实现，堆实现版本有大量的冗余，空间复杂度太高，但是时间复杂度是可以接受的。
	* 直接基于数组实现，记录2，3，5等基数的index，每次从中选择乘上基数后最小的值并更新index即可，这可以是说是一种DP的思想。
0. 字符串中第一个出现的只出现一次的字符
	* hashmap，同时记录第一次出现的位置和出现的频数。O(N)。
1. 数组中的逆序对
	* 归并排序的应用
	* merge的过程中，每次右侧先插入，`count += lr - ll`。
2. 两个链表的交点
	* TP
3. 排序数组中查找数字
	* BS
4. BST的第K大节点
	* 中序遍历二叉树（递归或非递归）
5. 二叉树深度/平衡二叉树
	* 平衡二叉树，使用深度变量，d<0表示树不平衡，子树不平衡，整个树一定不平衡。
6. 数组中数字出现的次数
	* 一个出现一次，其他数字出现2次
		* 位运算/异或
	* 一个出现一次，其他出现3次
		* 位运算/统计每位的和
7. 和为s的序列
	* 和为s的两个数
		* TP
	* 和为s的连续子序列，TP，同**48**。
	* 和为s的定长序列(不需要连续)，leetcode **3/4 sum**，TP升级版，多个指针MP。
8. 字符串反转
	* 字符串单词顺序反转
		* 先将整个串反转
		* 再逐单词反转
	* 字符串旋转
		* 前一部分反转
		* 后一部分反转
		* 整体反转
		* **用左右手比划**
9. 队列最大值
	* 滑动窗口最大值
		* 维护固定窗口的递减deque
	* 实现带有max函数的queue
		* 维护递减deque，**stack with minimum**使用的是递增栈。递减队列，递增队列，递减栈，递增栈都有用到，分场景，具体原因是什么？为什么要用递减或递增的结构，共性在哪里？？？
0. N个骰子的点数及概率
	* 递归或DP
1. 扑克牌中的顺子
	* multiset
2. 约瑟夫环
	* 原题每次沿顺时针方向删除第m个节点
	* 变式为每次先沿顺时针方向再沿逆时针方向删除第m个节点（老大的作业题）
	* 可以通过数学变换简化！
3. 倒卖股票
	* 记录之前（包括当日）的价格最小值，当日尝试卖出，更新当前最大利润
4. 求和但是不许用循环控制语句
	* 基于构造函数，利用new 对象数组时每个对象都会调用类的构造函数
	* 基于函数指针，使用双重否定判定实参是否为0。
5. 使用位运算实现加法
6. 构建乘积数组
	* 将待填充数组视为矩阵，两次循环算出结果。
7. stoi实现
	* 考虑空格、正负号、溢出
8. 树中两个节点的最近公共祖先
	* 树为BST，直接递归，沿一个分支查找即可
	* 存在指向父节点的指针，两个链表的第一个公共节点
	* 普通树，无指向父节点的指针，找出根节点到两个节点的path，两个链表最后一个公共节点

	


