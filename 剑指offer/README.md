---
style: summer

tags:
  - c++
  - 剑指offer
  - algorithm
  - 算法
  - interview
  - 面试
---


## 剑指offer

1. 自行设计C风格字符串类的赋值号重载函数
	* 返回自身引用(**\*this**)
	* 传入参数为常引用(拷贝构造函数也有这种要求，不然会有**编译错误！**)
	* 释放原有内存(**释放内存之前必须检测指针是否为空！**)
	* 判断是否为同一个对象(**用对象的地址是否相等判断**)
2. singleton
	* 将构造函数、拷贝构造函数、赋值函数、析构函数隐藏，使用static关键字。注意区分线程安全。

3. 寻找数组中的重复元素
	* 简单方法是排序然后找前后相等的元素
	* 通过统一的映射规则（相等）将数组元素映射到数组的index上，然后查看是否有碰撞。**模拟hash table的碰撞场景**。
	* 检测重复和检测missing是一样的思路！
	* 如果不允许改变数组，可以另外申请一个hash table，也可以使用二分法求解。
4. 矩阵查找
	1. 将一维数组砍断堆叠
		* 一维BS + index映射
	2. 非第一种情况
		* 每次选择角上的元素进行分割，每次可以排除一行或者一列
5. 字符串空格替换
	* TP，先将字符串扩容到应该有的长度，从后向前移动每个字符并实现替换。
6. 反向输出链表
	* 可以更改数据，直接头插法链表逆序，然后输出
	* 不能更改数据使用栈或者递归求解
7. 根据前序(或后序)遍历和中序遍历结果重建二叉树
	* 递归
8. 中序遍历的后一个节点
	* 分类要清晰
		* 有右子: 返回右子树最左的节点
		* 无右子: 向上回溯找到第一个节点时父节点左节点的节点，返回改节点的父节点
9. 双栈实现队列，双队列实现栈
10. 斐波那契数列
1. 旋转数组找最小值
	* BS。
	* 比较标准：`if (nums[mid] >= nums[0]) low = mid + 1`
	* 因为旋转后数组分为两个递增数组
2. 字符矩阵中找字符串的路径
	* 每个元素作为起点进行DFS，状态需要回溯
3. 机器人能够到达的位置
	* 将不可通过元素设为'X'，转为Maze。
4. **割绳子**
	* dp
		* 递推公式是:$dp[i]=\max_{j = 1}^{i/2}{dp[j] * dp[i - j]}$
		* 注意初始化为:$dp[0] = 0,dp[1] = 1, dp[2] = 2, dp[3]=3$

	* 贪心算法(**还是不太明白！！！**)
		* 绳子长度 $l>4$时，每次割下3，剩下的保留 
5. 数的二进制表示中有多少个1
	* 原数逐位右移
		* 若原数为负数，右移时符号位要保持为1，多次右移后，会进入死循环！
	* 1逐位左移，这个方式是正确的
	* 原数和原数减一相与，看能进行多少次这种操作！
		* **这个方法实在是太骚了！**
		* $x &= x-1$作为一个基本操作，无论x的正负，x都会逐渐收敛到0.
6. double power
	* 使用位运算
	* exponent的每一位的权重都是前一位对应权重的2次幂
7. 顺序打印从1到n位最大整数
	* dfs
	* 大树使用字符串处理
8. O(1)时间复杂度内删除节点
	* 直接将后一个节点的值拿来覆盖当前节点
	* 节点为最后一个时遍历找pre节点。
	* 时间复杂度按概率来算仍然是O(1)
9. 正则表达式
	* DP
	* 注意初始化
0. valid number
	* 直接上正则表达式
1. 按规则（如负数在前，正数在吼）分离数组
	* TP
	* 使用函数指针或函数对象作为rule，将关键行为剥离
2. 链表的第K个节点
	* TP
	* 注意边界(NULL、K过大、K过小等)
3. 链表成环检测即环入口
	* TP
4. 反转链表
	* 链表头插法
5. 合并两个有序链表
	* TP
6. 树的子结构
	* 2重递归
7. 二叉树镜像
	* 递归
8. 对称二叉树
	* 递归
9. 顺时针打印矩阵
	* 腾讯OMG面试题
0. 包含min函数的栈
	* 另存一个栈存储当前最小值，当且仅当被覆盖的时候才push
1. 栈的入栈出栈序列
	* DFS
	* 维护栈的状态和出入栈序列的位置就好
2. 二叉树层序遍历
	* 基本层序遍历（双queue）
	* 之字层序遍历（双stack,奇数层先入左子再入右子，偶数层先入右子再入左子）
3. 二叉树后序遍历
	* 非递归方法
		a. 先定义新的数据结构，记录右子是否访问过
		b. 每次先把所有左子入栈
		c. 如果栈顶右子访问过或为空，出栈并访问
		d. c中条件不满足，则重复b 
4. 和位某个值的path
	* dfs
	* 维护当前节点的sum和path，到达叶子节点进行判断
5. 复杂链表复制
	* hashmap
	* 如果已经被复制过，将指针指向复制得到的新节点
	* 没复制过，复制
6. BST和双向链表
	* dfs
	* 链表尾部注意使用双层指针！因为复制原变量之后在子程序中修改是无效的！
7. 序列化与解序列化二叉树
	* 使用istringstream和ostringstream（从stream读取字符串的时候默认以空格截断）
	* 利用先序遍历的方式
8. 字符串排列
	* DFS
		* 记录频率，每消耗一个字符将频率减1，注意回溯！
9. 数组中出现次数超过一半的数
	* 投票法,O(N)。
0. 最小的K个数
	* 基于partition的方法，O(N)，改变数组，不适用于海量数据（需要全部装入内存进行partition）
	* 基于堆的方式，O(NlogK)，适用于海量数据
1. 数据流中的中位数
	* 两个堆，较小的一半用大根堆，较大的一半用大根堆
	* 逻辑整清晰！
4. **丑数**就是微软那个面试题的原型！

