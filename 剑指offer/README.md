---
style: summer

tags:
  - c++
  - 剑指offer
  - algorithm
  - 算法
  - interview
  - 面试
---


## 剑指offer

1. 自行设计C风格字符串类的赋值号重载函数
	* 返回自身引用(**\*this**)
	* 传入参数为常引用(拷贝构造函数也有这种要求，不然会有**编译错误！**)
	* 释放原有内存(**释放内存之前必须检测指针是否为空！**)
	* 判断是否为同一个对象(**用对象的地址是否相等判断**)
2. singleton
	* 将构造函数、拷贝构造函数、赋值函数、析构函数隐藏，使用static关键字。注意区分线程安全。

3. 寻找数组中的重复元素
	* 简单方法是排序然后找前后相等的元素
	* 通过统一的映射规则（相等）将数组元素映射到数组的index上，然后查看是否有碰撞。**模拟hash table的碰撞场景**。
	* 检测重复和检测missing是一样的思路！
	* 如果不允许改变数组，可以另外申请一个hash table，也可以使用二分法求解。
4. 矩阵查找
	1. 将一维数组砍断堆叠
		* 一维BS + index映射
	2. 非第一种情况
		* 每次选择角上的元素进行分割，每次可以排除一行或者一列
5. 字符串空格替换
	* TP，先将字符串扩容到应该有的长度，从后向前移动每个字符并实现替换。
6. 反向输出链表
	* 可以更改数据，直接头插法链表逆序，然后输出
	* 不能更改数据使用栈或者递归求解
7. 根据前序(或后序)遍历和中序遍历结果重建二叉树
	* 递归
8. 中序遍历的后一个节点
	* 分类要清晰
		* 有右子: 返回右子树最左的节点
		* 无右子: 向上回溯找到第一个节点时父节点左节点的节点，返回改节点的父节点
9. 双栈实现队列，双队列实现栈
10. 斐波那契数列
1. 旋转数组找最小值
	* BS。
	* 比较标准：`if (nums[mid] >= nums[0]) low = mid + 1`
	* 因为旋转后数组分为两个递增数组
2. 字符矩阵中找字符串的路径
	* 每个元素作为起点进行DFS，状态需要回溯
3. 机器人能够到达的位置
	* 将不可通过元素设为'X'，转为Maze。
4. **割绳子**
	* dp
		* 递推公式是:$dp[i]=\max_{j = 1}^{i/2}{dp[j] * dp[i - j]}$
		* 注意初始化为:$dp[0] = 0,dp[1] = 1, dp[2] = 2, dp[3]=3$

	* 贪心算法(**还是不太明白！！！**)
		* 绳子长度 $l>4$时，每次割下3，剩下的保留 
5. 数的二进制表示中有多少个1
	* 原数逐位右移
		* 若原数为负数，右移时符号位要保持为1，多次右移后，会进入死循环！
	* 1逐位左移，这个方式是正确的
	* 原数和原数减一相与，看能进行多少次这种操作！
		* **这个方法实在是太骚了！**
		* $x &= x-1$作为一个基本操作，无论x的正负，x都会逐渐收敛到0.
6. double power
	* 使用位运算
	* exponent的每一位的权重都是前一位对应权重的2次幂
7. 顺序打印从1到n位最大整数
	* dfs
	* 大树使用字符串处理
8. O(1)时间复杂度内删除节点
	* 直接将后一个节点的值拿来覆盖当前节点
	* 节点为最后一个时遍历找pre节点。
	* 时间复杂度按概率来算仍然是O(1)
9. 正则表达式
	* DP
	* 注意初始化
0. valid number
	* 直接上正则表达式
1. 按规则（如负数在前，正数在吼）分离数组
	* TP
	* 使用函数指针或函数对象作为rule，将关键行为剥离
4. **丑数**就是微软那个面试题的原型！

