# sort  algorithms

Just for fun.

And for a good job.


## bubble sort

每次冒泡都将当前无序序列最大值或者最小值冒泡到最右侧，
可以记录一个bool常量，用于记录这一步是否有swap行为，
如果没有说明前面全都有序了，直接退出。


## quick sort

经典的方法是分为两部分，partition和recursion。
* partition部分
具有很强的对称性，每次循环都是找到最左侧不满足的元素，
放到后面，再找到最右侧不满足的元素放到左侧。

* recursion部分

注意有个`l < r`的条件！partition部分也有！

## insert sort



## select sort
选择无序数组中的最大（或最小）值放到无序数组的头部，实现排序。

## heap sort
基于数组实现，index的关系如下：
1. i(i >= 1)节点的父节点index为(i - 1) / 2.
2. i节点的左子节点index为i * 2 + 1, 右子节点的index为i * 2 + 2。
首先构造大根堆，从第一个有子节点的节点（数组长度为n时，
该节点index为n / 2 - 1）开始，开始调整。
3. 调整先找子节点中较大的那个，父节点比较，将大的节点换到父节点位置，
因为构造的时候从第一个有子树的节点开始调整，构造大根堆结束后每个子树都满足父节点大于子节点。
因此调整的时候发现父节点大于两个子节点就可以结束调整了。


