è¿™æ˜¯ä¸€é“**éå¸¸å…¸å‹ã€ä½†å±‚æ¬¡å¾ˆæ·±çš„é¢è¯•é¢˜**ï¼Œè¡¨é¢æ˜¯â€œåº“å­˜æ‰£å‡â€ï¼Œæœ¬è´¨è€ƒçš„æ˜¯ï¼š

> **åŸå­æ€§ / ä¸€è‡´æ€§ / å¹¶å‘å®‰å…¨ / å·¥ç¨‹æŠ½è±¡èƒ½åŠ›**

æˆ‘æŒ‰ä½ è¦æ±‚çš„ç»“æ„æ¥ï¼š
**é¢˜å¹²è§£æ â†’ å…³é”®ç‚¹ â†’ æŠ½è±¡æ¨¡å‹ â†’ å¤šç§è§£æ³•ï¼ˆç”±æµ…åˆ°æ·±ï¼‰â†’ C++ å®ç° â†’ æœ€ä¼˜è§£ç»“è®º**

---

# ä¸€ã€é¢˜å¹²è§£æï¼ˆé€è¡Œæ‹†ï¼‰

é¢˜ç›®æ ‡é¢˜ï¼š**å•†å“åº“å­˜æ‰£å‡**

ç»™å‡ºçš„ä»£ç éª¨æ¶ï¼ˆJava é£æ ¼ï¼Œé€»è¾‘è¯­è¨€æ— å…³ï¼‰ï¼š

```java
// æ‰¹é‡ä¸‹å•ï¼Œæ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
// å¦‚æœå……è¶³åˆ™æ‰£å‡å¹¶è¿”å› trueï¼Œå¦åˆ™ä¸æ‰£å‡è¿”å› falseï¼ˆåŸå­æ“ä½œï¼‰
class OrderItem {
    int productId;
    int quantity;
}

class Inventory {
    Map<Integer, Integer> stock; // productId -> å‰©ä½™åº“å­˜

    public boolean tryDeduct(List<OrderItem> items)
}
```

---

## é¢˜å¹²çš„**æ˜ç¤ºè¦æ±‚**

1. **æ‰¹é‡ä¸‹å•**

   * ä¸€æ¬¡è®¢å•é‡Œå¯èƒ½æœ‰å¤šä¸ªå•†å“
2. **åº“å­˜æ£€æŸ¥ + æ‰£å‡**
3. **åŸå­æ“ä½œ**

   * è¦ä¹ˆå…¨éƒ¨æ‰£æˆåŠŸ
   * è¦ä¹ˆä¸€ä¸ªéƒ½ä¸æ‰£
4. **è¿”å› boolean**

   * æˆåŠŸ true
   * å¤±è´¥ false

---

## é¢˜å¹²çš„**éšå«è¦æ±‚ï¼ˆé¢è¯•çœŸæ­£è€ƒçš„ï¼‰**

âš ï¸ è¿™äº›æ²¡å†™å‡ºæ¥ï¼Œä½†é»˜è®¤ä½ è¦è€ƒè™‘ï¼š

* åŒä¸€è®¢å•ä¸­ï¼š

  * å¯èƒ½æœ‰ **ç›¸åŒ productId**
* æ‰£å‡è¿‡ç¨‹ä¸­ï¼š

  * **ä¸èƒ½å‡ºç°æ‰£ä¸€åŠ**
* åœ¨å·¥ç¨‹è¯­å¢ƒä¸‹ï¼š

  * **å¹¶å‘å®‰å…¨**
  * **å¯æ‰©å±•**

---

# äºŒã€æ ¸å¿ƒå…³é”®ç‚¹æ€»ç»“ï¼ˆé¢è¯•å¿…ç‚¹ï¼‰

### âœ… å…³é”®ç‚¹ 1ï¼šè¿™æ˜¯ä¸€ä¸ªã€Œäº‹åŠ¡é—®é¢˜ã€

> tryDeduct â‰ˆ ä¸€ä¸ª **å°å‹äº‹åŠ¡**

æ»¡è¶³ï¼š

* Atomicï¼ˆåŸå­æ€§ï¼‰
* Consistentï¼ˆä¸€è‡´æ€§ï¼‰

---

### âœ… å…³é”®ç‚¹ 2ï¼šä¸èƒ½è¾¹æ£€æŸ¥è¾¹æ‰£

âŒ é”™è¯¯æ€è·¯ï¼š

```cpp
for item:
    if stock < qty: return false
    stock -= qty
```

ğŸ‘‰ å¦‚æœä¸­é€”å¤±è´¥ï¼Œ**åº“å­˜å·²ç»è¢«ç ´å**

---

### âœ… å…³é”®ç‚¹ 3ï¼šåŒä¸€å•†å“è¦å…ˆåˆå¹¶

```text
è®¢å•ï¼š
- å•†å“ A Ã— 2
- å•†å“ A Ã— 3

çœŸå®éœ€æ±‚ï¼šA Ã— 5
```

---

# ä¸‰ã€æŠ½è±¡æˆç®—æ³•é—®é¢˜

## è¾“å…¥

* å½“å‰åº“å­˜ï¼š`stock[productId]`
* è®¢å•åˆ—è¡¨ï¼š`items[]`

## è¾“å‡º

* boolï¼šæ˜¯å¦æˆåŠŸ
* å‰¯ä½œç”¨ï¼šæ˜¯å¦ä¿®æ”¹åº“å­˜

## ä¸å˜é‡

> **åº“å­˜æ°¸è¿œä¸èƒ½ < 0**

---

# å››ã€è§£æ³•ä¸€ï¼šæœ€ç›´è§‚ï¼ˆé¢è¯• 60 åˆ†ï¼‰

### æ€è·¯

1. å…ˆå¤åˆ¶ä¸€ä»½åº“å­˜
2. åœ¨å‰¯æœ¬ä¸Šå°è¯•æ‰£
3. æˆåŠŸæ‰è¦†ç›–åŸåº“å­˜

---

### C++ å®ç°ï¼ˆåŸºç¡€ç‰ˆï¼‰

```cpp
#include <unordered_map>
#include <vector>

using namespace std;

struct OrderItem {
    int productId;
    int quantity;
};

class Inventory {
public:
    unordered_map<int, int> stock;

    bool tryDeduct(const vector<OrderItem>& items) {
        auto temp = stock;  // æ‹·è´åº“å­˜

        for (const auto& item : items) {
            if (temp[item.productId] < item.quantity) {
                return false;
            }
            temp[item.productId] -= item.quantity;
        }

        stock = std::move(temp); // æäº¤
        return true;
    }
};
```

---

### è¯„ä»·

* âœ… æ­£ç¡®
* âŒ æ‹·è´æˆæœ¬é«˜
* âŒ æ²¡å¤„ç†åŒå•†å“åˆå¹¶
* âŒ å¹¶å‘ä¸å®‰å…¨

---

# äº”ã€è§£æ³•äºŒï¼šå…ˆèšåˆå†æ ¡éªŒï¼ˆé¢è¯• 75 åˆ†ï¼‰

### æ ¸å¿ƒä¼˜åŒ–ç‚¹

ğŸ‘‰ **åŒä¸€å•†å“å…ˆåˆå¹¶éœ€æ±‚**

---

### æ€è·¯

1. èšåˆè®¢å•ï¼š`need[productId] += quantity`
2. æ ¡éªŒåº“å­˜æ˜¯å¦æ»¡è¶³
3. ç»Ÿä¸€æ‰£å‡

---

### C++ å®ç°

```cpp
bool tryDeduct(const vector<OrderItem>& items) {
    unordered_map<int, int> need;

    for (const auto& item : items) {
        need[item.productId] += item.quantity;
    }

    // æ ¡éªŒ
    for (const auto& [pid, qty] : need) {
        if (stock[pid] < qty) {
            return false;
        }
    }

    // æ‰£å‡
    for (const auto& [pid, qty] : need) {
        stock[pid] -= qty;
    }

    return true;
}
```

---

### è¯„ä»·

* âœ… æ²¡æœ‰æ‹·è´
* âœ… æ—¶é—´å¤æ‚åº¦æ›´ä¼˜
* âŒ ä»ç„¶ä¸æ˜¯â€œäº‹åŠ¡å®‰å…¨â€
* âŒ å¹¶å‘ä¸‹ä»æœ‰é—®é¢˜

---

# å…­ã€è§£æ³•ä¸‰ï¼šæ˜¾å¼â€œæ¨¡æ‹Ÿ + æäº¤â€ï¼ˆé¢è¯• 85 åˆ†ï¼‰

### æ€è·¯ï¼ˆå·¥ç¨‹æ¨èï¼‰

* **æ ¡éªŒé˜¶æ®µ**ï¼šåªè¯»
* **æäº¤é˜¶æ®µ**ï¼šä¸€æ¬¡æ€§å†™

---

### C++ å®ç°

```cpp
bool tryDeduct(const vector<OrderItem>& items) {
    unordered_map<int, int> need;

    for (auto& item : items) {
        need[item.productId] += item.quantity;
    }

    // phase 1: check
    for (auto& [pid, qty] : need) {
        auto it = stock.find(pid);
        if (it == stock.end() || it->second < qty) {
            return false;
        }
    }

    // phase 2: commit
    for (auto& [pid, qty] : need) {
        stock[pid] -= qty;
    }

    return true;
}
```

---

### ä¸ºä»€ä¹ˆæ¯”æ–¹æ¡ˆäºŒå¥½ï¼Ÿ

* æ¸…æ™°è¡¨è¾¾ **äº‹åŠ¡ä¸¤é˜¶æ®µ**
* æ˜“æ‰©å±•ï¼ˆåŠ æ—¥å¿— / å›æ»šï¼‰

---

# ä¸ƒã€è§£æ³•å››ï¼šå¹¶å‘å®‰å…¨ï¼ˆé«˜çº§ / æ¶æ„çº§ï¼‰

> é¢è¯•å®˜è¿½é—®ï¼šâ€œå¤šçº¿ç¨‹æ€ä¹ˆåŠï¼Ÿâ€

### æ–¹æ¡ˆ Aï¼šå…¨å±€é”ï¼ˆç®€å•ä½†ç²—æš´ï¼‰

```cpp
#include <mutex>

class Inventory {
    unordered_map<int, int> stock;
    mutex mtx;

public:
    bool tryDeduct(const vector<OrderItem>& items) {
        lock_guard<mutex> lock(mtx);
        // ä½¿ç”¨è§£æ³•ä¸‰é€»è¾‘
    }
};
```

---

### æ–¹æ¡ˆ Bï¼šæŒ‰å•†å“ç²’åº¦é”ï¼ˆåŠ åˆ†ï¼‰

* productId â†’ mutex
* é¿å…æ— å…³å•†å“äº’ç›¸é˜»å¡
* éœ€è¦ **æ­»é”è§„é¿ï¼ˆæ’åºåŠ é”ï¼‰**

ğŸ‘‰ é¢è¯•è¯´åˆ°è¿™é‡Œï¼Œå·²ç»æ˜¯ **é«˜çº§å·¥ç¨‹å¸ˆæ°´å¹³**

---

# å…«ã€å¸¸è§é”™è¯¯ï¼ˆé¢è¯•å¿…æ­»ï¼‰

âŒ è¾¹æ£€æŸ¥è¾¹æ‰£
âŒ æ‰£ä¸€éƒ¨åˆ†å¤±è´¥ä¸å›æ»š
âŒ ä¸åˆå¹¶åŒå•†å“
âŒ æ²¡æ„è¯†åˆ°è¿™æ˜¯äº‹åŠ¡é—®é¢˜

---

# ä¹ã€æœ€ä¼˜è§£ç»“è®ºï¼ˆé¢è¯•å®˜è§†è§’ï¼‰

| è§£æ³•     | è¯„ä»·         |
| ------ | ---------- |
| æ‹·è´åº“å­˜   | æ­£ç¡®ä½†ä½æ•ˆ      |
| èšåˆæ ¡éªŒ   | åˆæ ¼         |
| ä¸¤é˜¶æ®µæäº¤  | âœ… **æ¨èç­”æ¡ˆ** |
| å¹¶å‘ç»†ç²’åº¦é” | â­ é«˜çº§åŠ åˆ†     |

---

# åã€é¢è¯•ä¸€å¥è¯æ€»ç»“ï¼ˆéå¸¸é‡è¦ï¼‰

> **è¿™é“é¢˜çš„æœ¬è´¨ä¸æ˜¯ map æ“ä½œï¼Œè€Œæ˜¯ä¸€ä¸ªâ€œæœ¬åœ°äº‹åŠ¡æäº¤é—®é¢˜â€ã€‚**

