463. Island Perimeter
https://leetcode.com/problems/island-perimeter/
就是逐一遍历所有的cell，用分离的cell总的的边数减去重叠的边的数目即可。在查找重叠的边的数目的时候有一点小技巧，就是沿着其中两个方向就好，这种题目都有类似的规律，就是可以沿着上三角或者下三角形的方向来做。一刷一次ac，但是还没开始注意codestyle的问题，需要再刷一遍。



455. Assign Cookies
https://leetcode.com/problems/assign-cookies/
给出两个序列，一个序列中的元素代表cookie的size，另外一个序列代表能满足孩子要求的最小cookie的size，问如何分配使得到的满意的孩子最多。先将两个序列都按从小到大顺序排序，然后按双路指针的方式解决。一刷一次ac，但是对于C++默认的sort函数的排序方式（从小到大还是从大大小）并不是很清楚。
算法库中的sort(beg, end, comp)函数实际使用快排，其中的comp是函数或者函数指针，签名是 bool comp(elem_type first_arg, elem_type second_arg)，返回的bool值的含义是第一个参数是否应该排在第二个参数的前面。而且默认参数会将较小的参数排在前面，即sort函数默认是从小到大排序！


453： Minimum Moves to Equal Array Elements
https://leetcode.com/problems/minimum-moves-to-equal-array-elements/
一开始自己对题目的理解出错了，浪费了不少时间。每次移动要求同时将n-1个元素加1，我看成了每次移动将其中2个元素加1。搞清楚题目真正含义之后，不太会做，参考了一下其他人的解题思路：给数组中的n-1个元素加1的操作等价于数组中“不加1的那个元素“减去1，然后数组中的所有元素都加1。我们知道，给所有的元素都加1并不能改变原数组中的数之间的差值。所以这题就转化为求最少的减1操作。而要使数组中的元素全部相等，又要使用减法。那么最少的次数就是让这些元素全部都等于数组中最小的数。所以得到的结果就是sum（所有元素和）-n*数组中最小元素。
注意看题目！一刷由于c++的api用的不熟，调用了min这个api，发现c++是没有这个api的，还有很多codestyle的问题，二刷注意了一下codestyle，一次ac，代码如下：

python版的代码一行完事：


383. Ransom Note
https://leetcode.com/problems/ransom-note/
就是用后一个串合成前一个串，条件是后一个串的每个字符只能用一次，这种题都可以利用c++的字符和int型转换来构建一个长为26度数组，每个数组表示一个key（前提是全大写或者全小写）。
一刷for循环中的计数器i没有声明类型（int），编译错误。二刷一次ac。



404. Sum of Left Leaves
https://leetcode.com/problems/sum-of-left-leaves/
看到这种题知道用递归，但是自己的思路很长时间没有理清。递归算法只要想明白一个节点的情况，其他节点都一样。对于每个节点如果指针为空，返回0；如果该节点飞空且左子树为叶子节点，则返回左叶子节点和右子树递归结果的和，否则返回左右子树的递归结果的和。一刷在处理左子树为叶子节点的情况时少写了val，二刷一次ac。

还有一种写了两个函数的算法，其实差不多。一刷第一次调用dfs函数参数给错了，只有一个root节点不算左叶子结点。二刷出现不明bug……没解决！

递归算法虽然简单明了，缺点是低效。尝试非递归算法，但是效率并没有提升，可能是因为递归与非递归算法用的是相同的原理：栈。一刷没有处理root为空的情况，忘记写返回语句。二刷也没有处理root为空的情况，另外没有声明类型，并且把变量名混淆。三刷处理了root为空的情况，但是处理栈顶元素的时候直接处理栈顶元素，其实应该处理栈顶元素的左右结点。四刷一次ac。


409. Longest Palindrome
https://leetcode.com/problems/longest-palindrome/
比较简单，如果字母个数为偶数，直接加，字母个数为奇数，加上减一后的值，由于回文串中间可以放一个长度为一的子串，因此如果有个数为奇数的字母，最后结果要加一。
一刷统计小写字母的出现次数时，条件写反了。计算最后结果时注意处理出现次数为奇数的字符。二刷一次ac。


448. Find All Numbers Disappeared in an Array
https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/
要求不能使用额外空间，只能在原数组上进行改动，将提到的元素对应的索引上的值加上负号，对后续的遍历操作影响不大（取绝对值就行）。由于在遍历到i之前已经将i后到元素置为负值，因此要在遍历到时候就加上绝对值。一刷中括号写成了小括号（取数组元素写成了函数调用，这两者的区别大了），在加入结果的时候少写了if语句。二刷一次ac。


442. Find All Duplicates in an Array
https://leetcode.com/problems/find-all-duplicates-in-an-array/
题目和上面那道题差不多，而且更简单！可是我没想到。和上一题的区别在于在处理重复赋值时直接就加入结果队列了。一刷一次ac。


414. Third Maximum Number
https://leetcode.com/problems/third-maximum-number/
找出n个数中的第m（m < n）大的数，这是个经典问题，我去望京面试的时候就被问到，我当时真菜，不然暑假可以拿好多钱，哼！当m不太大（m<4）时，都可以按同一种思路解决 ，就是同时设置多个max，遍历数组元素，分条件更新max。注意两点，一是max的初始化一定要比当前数组元素类型的最小值要小；二是max更新条件要写全，“=”的情况要排除。
一刷各max的更新顺序写反了，max更新条件没写全，没有用更大范围的数据类型。二刷一次ac。


289. Game of Life
https://leetcode.com/problems/game-of-life/
一刷判断自身的条件写错，死而复生的判断条件写错，代码效率不高。二刷代码结构有优化，但是效率还是不高，判断语句中==写成赋值号=，cell周环遍历数列写错（1写成-1）。三刷没有ac是因为不理解c++_11新特性。(auto n : vec)中的n是临时变量，修改n不能改变原来vector中的元素，因此在不需要修改vector中元素时遍历可以用auto，但是要修改vector中的元素，还是需要迭代器或者下标。


287. Find the Duplicate Number
https://leetcode.com/problems/find-the-duplicate-number/
一刷使用二分法，但是对二分法中low和high的更新细节不清楚，多个同类型的变量一起声明时应该用逗号隔离。二分法中low与high的更新过程和后面的返回值是low还是mid又有什么关系，还需要一点时间来理解。看了大神的博客知道发现更高效的算法，就是转化为链表内部环检测的问题。链表成环检测的问题是一个经典问题，大神的博客分析非常精彩，核心思想是用快慢指针走过的路程和环长等进行推理和证明，最后一个恒等式的利用非常精彩。大神博客地址为：http://www.cnblogs.com/ccdev/archive/2012/09/06/2673618.html,二刷使用该方法一次ac。


268. Missing Number
https://leetcode.com/problems/missing-number/
一开始掉进了前面的解法的坑里，老想着把元素当作索引，将正值变负值，然后找改变后的数组中的正值对应的元素，由于同时有n和0，这两种情况不能有效区分，而且也没说可以改动数组，故抛弃了这种解法。求和再做减法更方便，由于担心溢出，用了范围更大的数据结构，好像没什么用。


229. Majority Element II
https://leetcode.com/problems/majority-element-ii/
看了一篇博客，恍然大悟，很开心，就喜欢这种感觉。原博地址：http://blog.neoshell.moe/leetcode229.html
简而言之就是BM多数投票算法（Boyer-Moore Majority Vote algorithm）。代码效率好像不高，还要找找更高效的算法。一刷很快ac，二刷一次ac。
要注意变量的初始化，将n1，n2初始化为任意两个不同的数就行，对应counter设置为0是关键。还要注意一点第一次遍历结束只是明确了n1，n2是出现频率最高的数，但是对应的counter是不准的，需要重新计数！最后需要查看counter是否满足条件。


228. Summary Ranges
https://leetcode.com/problems/summary-ranges/
题目不难，需要注意变量的初始化和主循环之后的操作。记得返回处理结果！一刷算法效率不高，但是这是自己的思路，虽然代码写完之后自己也无法复现完整的思维过程。一开始思路不清晰，先写了一些不成熟的代码，然后不断修补，最后即使ac，思路已经支离破碎！还是需要完整而简洁的思路，如果自己没有这种思路，就去找优美的思路，然后逐行理解，把大神的思路变成自己的！
二刷我找到了一篇大神的博客，代码简洁而且思路清晰。用b记录本次范围的起始位置，用i作为索引。注意更新i和b时先更新i再更新b，而且是拿第i个元素和第i+1个元素比较，这样就不必在循环体外单独处理最后一个元素了！这点经验非常宝贵！三刷一次ac。


216. Combination Sum III
https://leetcode.com/problems/combination-sum-iii/
一刷使用dfs解决。我总是不太会构造递归，要注意这种题型！用递归解决问题，只要关注解决本层次的问题就好，通过条件筛选和循环将本层解决完，调用本身进入下一层。这种说法很简单，其实不容易做到！
注意剪枝条件，比如left可能等于i，每步循环中，需先将元素插入列表尾部，在下一层递归结束后，要将插入的元素从尾部取出！
二刷将“,”写成“;”，一定要注意书写！

209. Minimum Size Subarray Sum
https://leetcode.com/problems/minimum-size-subarray-sum/
一开始把题目意思理解错了，浪费了很多时间。subarray是原array的连续子序列，就像substring是原string的连续子序列一样。基于错误的理解，我使用dfs来解决，后来超时才反应过来。一定要好好看题，正确理解题意，往往事半功倍！正确地理解了题意之后，一刷很快ac。二刷更新min_size时没有判别，代码有小幅更新（能用while就不要用for）。
用sum和left记录当前subarray的和与起始位置，注意同时更新sum和left，每次更新min_size之前需要对当前subarray的size进行判别。


162. Find Peak Element
https://leetcode.com/problems/find-peak-element/
一刷使用直接遍历的方法，很笨，写了一半发现可疑从两头一起开始遍历，但是时间复杂度并没有明显改善。二刷使用基于迭代的二分法，二分法的合理性感觉可以用罗尔定理证明。变量名写错，mid的判断条件写错。
以后就把自己的二分法固定下来，while里面填low < high, 更新方式为high = mid， low = mid + 1， 返回low。这样以来，写代码的时候实际要判断的只有更新条件了！


二分法还可以用递归的方式表现。


154. Find Minimum in Rotated Sorted Array II
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/
原来algorithm库中是有min（max）函数的，也有min(max)_element函数的！但是min（max）函数只接受两个参数，没什么实用价值，min(max)_element函数也没什么大的使用价值，返回迭代器。
其实比较简单，一刷一次ac。说实在的，自己被这个hard标志吓得不轻。

153. Find Minimum in Rotated Sorted Array
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
和154一模一样。


152. Maximum Product Subarray
https://leetcode.com/problems/maximum-product-subarray/
原理是dp，但是我对dp并不熟！关键在于当前的max和min并不是全局的max和min，每遍历一个元素就要更新全局的max（res）。一刷变量名写错，效率也不高。二刷由于不理解DP，更新过程写错！三刷一次AC。



344. Reverse String
https://leetcode.com/problems/reverse-string/
字符串翻转，很简单。使用内置函数swap简化了代码，一次AC。


136. Single Number
https://leetcode.com/problems/single-number/
用亦或进行位运算。可以想象为一个多层公寓，每个公寓住着0或者1，亦或运算就是所有圆柱体内的数字进行亦或。一次AC。


104. Maximum Depth of Binary Tree
https://leetcode.com/problems/maximum-depth-of-binary-tree/
一刷使用层序遍历（BFS），一次AC，效率不高。二刷使用DFS，一行解决问题，效率也非常高，一次AC。


389. Find the Difference
https://leetcode.com/problems/find-the-difference/
对于字符串的常用方法，将字符转为数组下表，从而将空间复杂度降到O(N)。二刷一次AC。


226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
使用递归，较简单，二刷一次AC。


169. Majority Element
https://leetcode.com/problems/majority-element/
二刷使用BM投票算法，因为初始化错误没能AC，深层原因在于没能透彻理解BM算法。


206. Reverse Linked List
https://leetcode.com/problems/reverse-linked-list/
比较简单，但是非常常考！二刷比较注意codestyle，一次AC。


100. Same Tree
https://leetcode.com/problems/same-tree/
使用递归，教简单，二刷改善了codestyle，逻辑也更清晰，一次AC。


128. Longest Consecutive Sequence
https://leetcode.com/problems/longest-consecutive-sequence/
被hard标签吓住，确实也没想到好方法，要求O(N)的复杂度。先看的discuss区，discuss区的TOP1解法讲解非常好。大神用的是Python，我用C++实现的。比较简单，一刷end计数器退出循环时的数值搞错，WA。
改正之后AC。二刷unordered_set的定义中没有将模板实例化。三刷一次AC。


126. Word Ladder II
https://leetcode.com/problems/word-ladder-ii/
使用BFS，代码非常复杂，这道题确实很难，通过率仅13%！需要考虑的东西很多，看大神的代码看了3天才算弄明白怎么回事。还是要动笔自己跑几个demo，这样非常有助于了解算法的精妙之处。大神的代码是用java写的，我把它翻译成了C++，也挺有难度的！一刷在XCODE上写的，debug花了不少时间，不过这样一来对C++的容器的使用更熟练了。非常关键的一点在于不能重复向队列中插入元素！二刷有两处语法错误，一个函数签名写错（少写了一个引用符号），导致返回结果为空，比起一刷进步很大，非常开心。三刷一次AC，写的时候细心一点，还是可以一次AC的！


121. Best Time to Buy and Sell Stock
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
比较简单，但是看了一会没什么思路，看了discuss区的答案。思路是遍历每天的股价，记录今日之前的最低价和最高收益，和今日股价比较更新最低价，最高收益和今天卖出的收益比较更新。一刷一次AC，但是思路不是自己的！


120. Triangle
https://leetcode.com/problems/triangle/
又是DP，从底网上找。一刷for循环里面的变量名写错，也是醉。这种算法的空间复杂度为O(N)，还有一种空间复杂度为O(1)的算法，下次来的时候好好调研一下。


106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
再次吊死在二叉树上！这个算法人来做不难，很好理解，但是翻译成机器能理解的算法就很困难！这就是人类和机器思维的区别吗？一刷在IDE上写的，没理解透彻。非递归算法确实不太好懂，明天再试试递归算法。还是递归算法比较容易理解。


105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
和上一题的方法完全一样，我用的是递归方法，但是参数传递已经尽量少了，所以性能牺牲不是太多，因为牺牲在函数调用上。一刷函数签名少写了引用符号，导致运行时内存溢出。二刷AC。


80. Remove Duplicates from Sorted Array II
https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
比较简单，将重复次数小于3的元素往前移动，其他元素不动，就得到了重复次数最多为2的元素的个数。一刷题目理解不清，循环条件写错。二刷循环条件写错。三刷一次AC。


81. Search in Rotated Sorted Array II
https://leetcode.com/problems/search-in-rotated-sorted-array-ii/
适合用二分法，但是“十个二分九个错”！花了不少时间。本质是分类问题，关键在于选择分类标准，分不了走的步子小一点！画图是个解决问题的好办法。一刷分类标准选的不好，在XCODE上debug很长时间才AC。


78. Subsets
https://leetcode.com/problems/subsets/
一刷由于对vector的一些成员函数不熟悉，没有AC。二刷一次AC。讨论区第一名的算法是基于bitmap做的，一刷由于对vector的多元素版本的构造函数格式不熟，没能AC。二刷一次AC。


75. Sort Colors
https://leetcode.com/problems/sort-colors/
这道题是让手写排序，一刷手写快排没AC。二刷由于多次将左侧边界想当然地视为0（其实是l）没能AC。讨论区第一名的算法针对特殊情况（只有0， 1， 2三个数字）对普适的排序算法做了优化，一刷循环条件写错没AC。二刷思路不清晰，没AC，注意需要两层循环，内层循环只处理连续的符合条件的情况，外层需要等于因为该index对应的值谁也不知道是几。第二种算法的在时间效益上不如快排。


74. Search a 2D Matrix
https://leetcode.com/problems/search-a-2d-matrix/?tab=Description
二分法的升级版，一刷选对应行的时候没考虑全，导致在[[1], [3]]找1这个case下死循环。讨论区第一名算法将matrix视为一维数组，一维数组的索引和二维数组索引的关系是：对于m*n矩阵A，如果将其视为一维数组B，则B[x]=A[x / n][x%n]。一刷本地IDE上debug艰难AC。二刷在纸上纯手写一次AC。


73. Set Matrix Zeroes
https://leetcode.com/problems/set-matrix-zeroes/?tab=Description
我套用74题的方法，将矩阵视为一维数组，发现并不合适。讨论区第一名的算法很好，将第一行第一列作为标志，第一列使用单独的标志。顺序遍历将标志置0，逆序遍历按标志将元素置0。算法复杂度高些，但是好理解。一刷写错变量名，没AC。二刷一次AC。


64. Minimum Path Sum
https://leetcode.com/problems/minimum-path-sum/?tab=Description
DP算法，Discuss区第一名将空间复杂度从O(N^2)缩减到O(N)，并且给出了完整的解析，看了两个晚上，才有点明白。一刷AC，但是还要再刷！二刷一次AC。


62. Unique Paths
https://leetcode.com/problems/unique-paths/?tab=Description
一种算法和64题相似,一刷变量名写错没能AC，二刷一次AC。另一种直接算C(N, k)，数学真是太美好了。算组合数的算法时间复杂度高于DP算法，是因为乘法远比加法费时间！一刷表达式写错没能AC。


63. Unique Paths II
https://leetcode.com/problems/unique-paths-ii/?tab=Description
62，63， 64题思路都一样，初始化和循环过程稍有差异。先初始化cur，然后以内部遍历列外部遍历行的方式逐步更新cur，对于特殊的第一行和第一列单独处理。一刷vector的初始化写错没能AC。二刷一次AC，这种题算是真的理解了。


59. Spiral Matrix II
https://leetcode.com/problems/spiral-matrix-ii/?tab=Description
挺有意思的一道题，开始我以为矩阵有两种分解方式：第一种很有美感，结果这是个陷阱，n为偶数时可以正确返回结果，当n为奇数时，矩阵最中间的那个格会形成死循环；第二种才是正确的分解。一刷嵌套式vector的初始化语法写错，没能AC。二刷循环中更新j出错，没能AC。


56. Merge Intervals
https://leetcode.com/problems/merge-intervals/?tab=Description
比较简单，没太多技巧。我也有思路，但是远远达不到讨论区C++第一名的算法的简洁。第一名的算法在调用sort函数的时候重载了[]操作符，我不太理解这种方法，在函数外定义了自己的compare函数。有两个问题没搞清，一是为什么自己定义的compare函数无论是重载操作符形式还是一般的返回bool的形式，都只能用小于号，不能加等于号，加了就导致运行时错误！第二点就是重载操作符的理解又忘了！一刷没有AC。二刷vector的定义出错，myCompare函数没有设定为static，还自作聪明地使用引用类型！没能AC。注意更新end时，判断条件用<=。


55. Jump Game
https://leetcode.com/problems/jump-game/?tab=Description
看了讨论区的两个算法，一个很简洁，4行完事，思路是遍历每个元素，看每个元素当前能达到的最远处是否包括当前元素（本质是0能不能跳过），一刷AC。另一个效率高些，思路更清晰，就是看0元素能不能跳过去，一刷没AC，注意循环从倒数第二个元素开始，因为最后一个元素的值是不用考虑的。二刷思路错了，不应该比较sum和dis，而应该比较dis和相应位的num，没能AC。但是这次刷理解了中间cur为什么可以直接减。


54. Spiral Matrix
https://leetcode.com/problems/spiral-matrix/?tab=Description
按照59题相似的思路，出现了两个比较大的BUG，一是内层while循环索引没有递增/减，二是在两次反向遍历的时候要加一个判断条件，以免与正向遍历的是同一行/列。一刷没AC。二刷写错了最后一次从下向上遍历过程的行的index的初始化值，没能AC，但是对代码进行了优化。


53. Maximum Subarray
https://leetcode.com/problems/maximum-subarray/?tab=Description
还是DP算法，不好理解。画了个函数图像，感觉稍微好些。序列中的每个数都是sum的导数，这么看的话就可以理解。DP算法好些可以解释连续的问题。很奇妙。一刷AC。二刷一次AC。


48. Rotate Image
https://leetcode.com/problems/rotate-image/?tab=Description
采用讨论区第一名的算法，效率不是很高，但是很容易明白。是一种普适的方法。对于旋转先将矩阵进行行逆序，然后对角互换。对于逆时针旋转则是先进行列逆序。一刷AC。二刷一次AC。


40. Combination Sum II
https://leetcode.com/problems/combination-sum-ii/?tab=Description
讨论区第一名的算法先对候选排序，然后使用DFS，搜索路径。注意去除可能重复的路径和并进行必要的剪枝。一刷变量名写错没AC，对去重的理解也只限于想象，没有验证。讨论区第一名算法我添加了剪枝之后，算法执行时间缩短很多，还是挺有成就感的。二刷一次AC。


39. Combination Sum
https://leetcode.com/problems/combination-sum/?tab=Description
做了第40题之后，做这道题就觉得比较简单了，可以画树状图来理解计算机的求解过程。一刷for循环中；写成了，没AC。二刷cand写成了res，没能AC。


35. Search Insert Position
https://leetcode.com/problems/search-insert-position/?tab=Description
非常简单，一次AC。


34. Search for a Range
https://leetcode.com/problems/search-for-a-range/?tab=Description
比较简单，一看就有思路。二分法，第一个版本是分别用两次二分查找查上界和下界，一次AC。终于明白了二分查找查找符合目标下界和符合目标上界的区别和联系，联系在于每次循环必须更新要招的那个界限（low或者high）！区别在于求下界时mid要跟随下界变化，求上界的时候mid要跟着上界变化，这样就不会出现死循环的状况了，这种看透彻的感觉很爽。算法效率不高。第二版先使用二分查找找到下界，然后从下界往后遍历找上界，然后就掉进了C++的坑里了。C++的[]操作是不检查[]中的index是否超出vector的size的，所以在使用[]进行遍历的时候，一定要加上size的限定条件。第二版没AC。二刷没有AC，题意理解错误，代码开始没有判空。


33. Search in Rotated Sorted Array
https://leetcode.com/problems/search-in-rotated-sorted-array/?tab=Description
比81题简单一些，因为不用考虑重复。81题做完就扔了，也没来得及复习，分类标准理解了，但是分类细节还是没把握好，一刷没AC。算法的效率也不高。二刷没AC，没有处理好low=mid的情况，这种情况不能和任何一种情况合并，因为在更新high的时候会把high更新到mid - 1，这问题就大了！而实际上这个时候应该更新low（low++）。


31. Next Permutation
https://leetcode.com/problems/next-permutation/?tab=Description
第一眼没思路，选择了讨论区一个比较好理解的算法，效率还不错。先从后将降序变为升序，然后找升序中前一个数字的上界与该数字替换。一次AC，但是理解不够。二刷查了API文档之后一次AC。


18. 4Sum
https://leetcode.com/problems/4sum/?tab=Description
第一眼使用DFS，很快写出来了，debug了很久没AC。选择了讨论区一个基于C++的算法，一刷没AC，变量名写错，忘记对nums进行sort操作，根本在于理解深刻。二刷没AC，变量名写错，最后更新l和r的过程写错。三刷没AC，还是最后更新l和r的操作写错！！这个题可以视为一棵定深的树的遍历，剪枝规则也很简单，就是除当前层的第一个节点外，其余节点如果和前一个节点值相同就减掉。最后要注意的是处理2sum的时候，要先更新l和r然后再进行剪枝的操作，否则会陷入死循环。


16. 3Sum Closest
https://leetcode.com/problems/3sum-closest/?tab=Description
和18题非常相近，而且要简单很多。仿照18题的思路写了大部分，结果最后一行更新left和right的时候走入弯道了，看了讨论区的算法有了想法。变量名写错，三目运算符写错，一刷没能AC。二刷变量n没有声明，没有AC。


15. 3Sum
https://leetcode.com/problems/3sum/?tab=Description
15，16，18思路一样，但是都没有一次AC。一种算法，在不理解的情况下，至少要写5次才能懂得每一步的精髓！一刷去重条件写错，没能AC。二刷一次AC。


11. Container With Most Water
https://leetcode.com/problems/container-with-most-water/?tab=Description
一开始理解错题意，把矩形当成梯形来算，看了讨论区算法的思路后，自己写出来的。一刷AC，但是还需要再刷。二刷迭代时没有更新结果，没能AC。三刷连思路都没了，花了很长时间。我的思路是选可能留下的，而这种情况并不容易搞，答案是筛去不符合的！这样就简单很多。还要再刷！！


535. Encode and Decode TinyURL
https://leetcode.com/problems/encode-and-decode-tinyurl/#/description
比较简单的一道题，但是就是没思路，好烦，做的题还是不够多，很多C++的STL操作都忘掉了，上周写了不少python之后，现在写C++老是忘记写；在不同的语言之间来回切换容易精神错乱！一刷没AC。


508. Most Frequent Subtree Sum
https://leetcode.com/problems/most-frequent-subtree-sum/#/description
不算难，现在衡量难与不难的标准是看了有没有思路。有思路但是花很长时间肉眼debug才A掉这个题。而且思路没有简化到极致。最大的那个count可以在遍历树的过程中找到，我是遍历完树之后再遍历map找的，map中的元素可以自动初始化，这种情况和python不一样，不用判断键是否存在！经过优化之后，代码非常简洁而且效率提高了一倍。一刷没有AC！二刷没有一次AC，注意iterator的操作不能使用<，只能使用!=和=。


500. Keyboard Row
https://leetcode.com/problems/keyboard-row/#/description
现在连easy级的题都没法一刷AC了，真是菜啊！再刷！！！二刷一次AC。


454. 4Sum II
https://leetcode.com/problems/4sum-ii/#/description
没有思路，要再刷两遍！一刷没AC，res更新不是加1，而是加上map中的count！二刷一次AC，但是思路理解并不流畅！还要再刷!


451. Sort Characters By Frequency
https://leetcode.com/problems/sort-characters-by-frequency/#/description
比较简单，但是比较考基本功，但是还是不明白为啥要用static关键字！！！一刷没AC，注意map使用[]操作查询时，不存在的键会自动生成！而值会调用相应的默认构造函数！这是c++的一大优点。


438. Find All Anagrams in a String
https://leetcode.com/problems/find-all-anagrams-in-a-string/#/description
没思路，一刷没AC，注意滑动窗口，这是个等大小的窗口，只是用vector而不是用map的算法效率不高。


380. Insert Delete GetRandom O(1)
https://leetcode.com/problems/insert-delete-getrandom-o1/#/description
一刷没AC，注意get_random的时候index不能为0！


274. H-Index
https://leetcode.com/problems/h-index/#/description
一刷没思路！注意vector和Hashmap的查找复杂度都是O(1)！开数组，多加一个元素用于存储引用数大于size的个数。


166. Fraction to Recurring Decimal
https://leetcode.com/problems/fraction-to-recurring-decimal/#/description
一刷没AC，磕磕碰碰，花了很长时间，但是最后肉眼debug成功了。再刷！ 注意极端情况如0，如负数，还有超出界限的问题。效率不高。
discuss区c++第一名的算法非常简洁，和我思路一样。


138. Copy List with Random Pointer
https://leetcode.com/problems/copy-list-with-random-pointer/#/description
一刷没AC，但是按照自己的思路最后还是debug成功了，再刷！！对链表的更新过程不熟悉，使用一个hash表记录已经访问过的节点。


94. Binary Tree Inorder Traversal
https://leetcode.com/problems/binary-tree-inorder-traversal/#/description
一刷没AC，忘完了！赶紧拾起来！二叉树的各种遍历的递归和非递归算法要烂熟于心！再刷！！！就像快排一样！！


49. Group Anagrams
https://leetcode.com/problems/anagrams/#/description
一刷没有AC。一看就有思路，不清楚map和unordered_map的区别出错。map基于红黑树，是用树实现的hashmap，而unordered_map直接基于hash table，使用unordered_map的时候必须保证key的类型有hash()方法！容器类型除了string外默认是没有hash()方法的！另外map和unordered_map的key无论是何种类型，只要使用[]方法访问而且key不存在就会调用value的默认构造函数。因此不需要判断，对于value为容器的情况一样适用，我们要保证的是在访问value之前，先确保调用了[]方法。


445. Add Two Numbers II
https://leetcode.com/problems/add-two-numbers-ii/#/description
很简单，但是没有一次AC！而且我的方法时间和空间复杂度都比较高。


328. Odd Even Linked List
https://leetcode.com/problems/odd-even-linked-list/#/description
很简单的一道题，题意理解错误，正确理解题意后一次AC。


148. Sort List
https://leetcode.com/problems/sort-list/#/description
对排序还是有点怵，没思路，看了归并排序的思路自己写没有一次AC，漏掉了merge步骤更新h。再刷！！


147. Insertion Sort List Add to List
https://leetcode.com/problems/insertion-sort-list/#/description
比较简单，一刷没AC，查找插入位置时应该从h->next开始，而不应该冲h开始！


143. Reorder List
https://leetcode.com/problems/reorder-list/#/description
挺简单的，看了就有思路，算法还不错，没有一次AC，再刷！借用上一题的思路，用双指针分离，将后段逆序，之后merge。注意merge阶段保存的是插入进来的node！


142. Linked List Cycle II
https://leetcode.com/problems/linked-list-cycle-ii/#/description
一刷由于判断语句中“==”写成了“=”没能AC，链表成环还有不清楚的地方，就是为什么相遇时slow不可能完整遍历链表了？？注意使用新起的节点作为起始点，避免head指向head的情况。二刷没有一次AC，添加新的头结点忘记和原链表连上了，精简了代码。三刷第一步判断head之后返回写错，应该直接返回NULL，没有AC。


92. Reverse Linked List II
https://leetcode.com/problems/reverse-linked-list-ii/#/description
很简单，一刷AC。


61. Rotate List
https://leetcode.com/problems/rotate-list/#/description
比较简单，一刷没有AC，思路有一点错误，不应该直接把旋转点之后的节点直接使用头插法，对k也要非常注意，k可能超出length。总结一点：如果链表中head不稳定，可能变化，就要另外设置一个新的head！二刷一次AC。


82. Remove Duplicates from Sorted List II
https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/#/description
比较简单，一次AC。


86. Partition List
https://leetcode.com/problems/partition-list/#/description
比较简单，一刷AC，注意用尾插法！


109. Convert Sorted List to Binary Search Tree
https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/#/description
对平衡二分查找树不熟悉，很恐惧！思路不是自己的，自己在纸上写了一遍才算理解了算法，一刷AC，还要再刷！二刷一次AC。


523. Continuous Subarray Sum
https://leetcode.com/problems/continuous-subarray-sum/#/description
思路不是自己的，一刷没AC，因为变量写错CE，因为没考虑K会是负数而WA，还要再刷！


462. Minimum Moves to Equal Array Elements II
https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/#/description
这个问题中数列的平衡杆不一定就是均值，因为经过排序后两端每对数字移动的总距离和均值无关。当数字有偶数个时，以均值直接算作平衡杆正确；当数字有奇数个且中间那个数恰好为均值时，用均值作为平衡杆也正确；但是当中间那个数不是均值时，就应该用中间那个数作为平衡杆，亦即中间那个数不需要移动！
一次AC，但是思路不是自己的，还要再刷！


441. Arranging Coins
https://leetcode.com/problems/arranging-coins/#/description
很简单的数学问题，就是个一元二次方程求解的问题，我忘记用公式了。用了个O(long N)的方法，用公式一次一次开方就OK了。一次AC。


423. Reconstruct Original Digits from English
https://leetcode.com/problems/reconstruct-original-digits-from-english/#/description
比较简单的多元方程组的问题，一刷没AC，因为string和int的互换方法不清CE了，算法效率也不是很高。


415. Add Strings
https://leetcode.com/problems/add-strings/#/description
很简单，看了就有思路，一次AC。算法效率好像不太行。


400. Nth Digit
https://leetcode.com/problems/nth-digit/#/description
思路不是自己的。一刷没AC，因为base设为int类型越界导致WA。再刷！


413. Arithmetic Slices
https://leetcode.com/problems/arithmetic-slices/#/description
比较简单，一刷没有AC，不用设置两个begin和end两个变量，只需一个middle就可以了，注意middle从1到A.size() - 2，因为这个WA。因为==写成=CE。


372. Super Pow
https://leetcode.com/problems/super-pow/#/description
思路不是自己的，一刷AC，还要再刷！递归设计的很好！


368. Largest Divisible Subset
https://leetcode.com/problems/largest-divisible-subset/#/description
思路不好，有漏洞，看了讨论区的C++算法，一刷没AC。因为开始没对数组没排序得了WA。对大神的思路理解的不够深入，再刷！！


367. Valid Perfect Square
https://leetcode.com/problems/valid-perfect-square/#/description
一道简单的二分查找，一刷没有AC。注意一个公式1 + 3 + 5 + 7 + 9 + …… = n^2!因为mid设为int，结果溢出得了WA。


365. Water and Jug Problem
https://leetcode.com/problems/water-and-jug-problem/#/description
巨硬笔试题，数论问题，挺难的！证明还挺复杂……。最大公约数GCD和最小公倍数LCM还不太会弄！一刷一次AC。但是思路理解起来还是挺费劲的！再刷！


343. Integer Break
https://leetcode.com/problems/integer-break/#/description
一道规律题，一刷没有AC，以为大于号写成小于号得了WA，需要用导数来推导，果然是数学题！再刷！


319. Bulb Switcher
https://leetcode.com/problems/bulb-switcher/#/description
规律题，发现了一部分规律，但是没有继续深入，发现的规律还比较浅层。一刷一次AC。


69. Sqrt(x)
https://leetcode.com/problems/sqrtx/#/description
不难，一刷没有AC。二分法判断条件用乘法溢出，导致WA。经典方法是Newton法，但是不太容易理解。再刷！


313. Super Ugly Number
https://leetcode.com/problems/super-ugly-number/#/description
比较复杂，我有个思路，但是没有想到怎么实现。看了讨论区算法才搞明白，思路不是自己的，一次AC，还要再刷！


279. Perfect Squares
https://leetcode.com/problems/perfect-squares/#/description
没思路，讨论区使用的是DP算法，还有一种数学算法，不太懂，放弃了！一刷没有AC，变量没有定义拿了CE！再刷！


264. Ugly Number II
https://leetcode.com/problems/ugly-number-ii/#/description
和313题很像，我也是用的313题的方法，效率还不错，一刷AC。


50. Pow(x, n)
https://leetcode.com/problems/powx-n/#/description
比较简单，但是思路不好，只想到O(N)的时间复杂度的算法，二分算法的时间复杂度可以达到O(log N)。有递归和非递归两种方式，没有一次AC，再刷！注意：INT_MIN和INT_MAX的绝对值不同，需要用long或者long long类型来暂时存储n！


60. Permutation Sequence
https://leetcode.com/problems/permutation-sequence/#/description
题目不简单，看别人的代码很难，对思路还不是很清晰，再刷！


43. Multiply Strings
https://leetcode.com/problems/multiply-strings/#/description
大数乘法，自己写出来的，挺开心。一刷没有AC，res和进位计数c的更新应该写在第一层循环体，我写到了第二层循环体中。再刷！


29. Divide Two Integers
https://leetcode.com/problems/divide-two-integers/#/description
一刷AC，思路不是自己的，再刷！思路很棒，用二进制的方式做的，时间复杂度是O(log N)，其实看题目的要求就知道需要用二进制的移位运算。


12. Integer to Roman
https://leetcode.com/problems/integer-to-roman/#/description
思维局限在一次产生一个字母上了，看了讨论区的思路才豁然开朗。一刷AC，但是思路不是自己的，还要再刷！连同其逆过程也要再刷！


567. Permutation in String
https://leetcode.com/problems/permutation-in-string/#/description
一个简单的滑动窗口的题目，没思路，真是菜！一刷AC，还要再刷！


532. K-diff Pairs in an Array
https://leetcode.com/problems/k-diff-pairs-in-an-array/#/description
很简单，没有一次AC，再刷！


524. Longest Word in Dictionary through Deleting
https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/#/description
思路不是自己的。一刷因为多个变量在同一行中定义写法出错拿个CE！对于pj的增长方式还是没办法提出比较容易理解的模型。再刷！！


3. Longest Substring Without Repeating Characters
https://leetcode.com/problems/longest-substring-without-repeating-characters/#/description
挺难的，虽然标注的是easy级别！没能完全领会解法的妙处，再刷！


557. Reverse Words in a String III
https://leetcode.com/problems/reverse-words-in-a-string-iii/#/description
面试被难倒的一个问题，一刷没有AC，真是辣鸡！再刷！


520. Detect Capital
https://leetcode.com/problems/detect-capital/#/description
一次AC。注意判断逻辑顺序。


541. Reverse String II
https://leetcode.com/problems/reverse-string-ii/#/description
一刷AC。


434. Number of Segments in a String Add to List
https://leetcode.com/problems/number-of-segments-in-a-string/#/description
一刷临界情况没写准，没AC。


551. Student Attendance Record I
https://leetcode.com/problems/student-attendance-record-i/#/description
一刷AC。


459. Repeated Substring Pattern
https://leetcode.com/problems/repeated-substring-pattern/#/description
不难，但是我的解法时间复杂度比较高，一刷没AC.解答区有时间复杂度为O(N)的DP算法。


521. Longest Uncommon Subsequence I
https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description
一行完事，但是很绕！再刷！


5. Longest Palindromic Substring
https://leetcode.com/problems/longest-palindromic-substring/#/description
解法比较朴素，遍历每个字符，沿两侧展开，更新起始点和最大长度。一刷没AC，再刷！


385. Mini Parser
https://leetcode.com/problems/mini-parser/#/description
不算简单，用到istringstream，不好理解！子函数对流修改后，父函数要clear()才能得到正确的指针！一刷AC但是不太理解递归，再刷！


6. ZigZag Conversion
https://leetcode.com/problems/zigzag-conversion/#/description
比较简单，一刷没AC，没有认真考虑边界条件。numRows为0直接返回原串即可。


556. Next Greater Element III
https://leetcode.com/problems/next-greater-element-iii/#/description
不难，但是忘记怎么求下一个排列的算法了。标准库有api可以用！再刷！


227. Basic Calculator II
https://leetcode.com/problems/basic-calculator-ii/#/description
算法不是自己的！一刷n的更新写到if语句里导致WA，没能AC。再刷！


17. Letter Combinations of a Phone Number Add to List
https://leetcode.com/problems/letter-combinations-of-a-phone-number/#/description
算法自己写的，但是很多天不刷，已经没感觉了！一刷没AC，还各种CE！再刷！！！


336. Palindrome Pairs
https://leetcode.com/problems/palindrome-pairs/#/description
想有个好点的算法比较难，还不太理解讨论区大神的算法，一刷没AC。忘记边界拿了WA，再刷！


539. Minimum Time Difference
https://leetcode.com/problems/minimum-time-difference/#/description
一刷没AC，一开始没看懂题意导致WA。看了解答区的算法手写各种CE！再刷！


583. Delete Operation for Two Strings Add to List
https://leetcode.com/problems/delete-operation-for-two-strings/#/description
一刷没有AC，min函数只能比较两个数，编译错误。DP算法不太懂，再刷！！二刷没有一次AC，j初始化错误。没完全理解算法，再刷！自己手动运行了几遍代码，终于搞懂了。dp的元素矩阵表示应该删除的字符个数，最外围那一行和列表示一个串为子串，而另外一个串为空串！但是没动手再刷一次！再刷！三刷一次AC。


468. Validate IP Address
https://leetcode.com/problems/validate-ip-address/#/description
一刷没AC，getline在这个题目中有妙用！题目不难，但是边界条件非常多！坑很多！再刷！


522. Longest Uncommon Subsequence II
https://leetcode.com/problems/longest-uncommon-subsequence-ii/#/description
思路不是自己的，一刷废了很大劲没AC。用了两种方法，直接构造带有cmp函数的map失效，还没弄明白原因！再刷！


91. Decode Ways
https://leetcode.com/problems/decode-ways/#/description
思路不是自己的，一刷没AC。因为函数返回值类型写错拿了CE！这是致命的错误！DP算法还不是很理解，再刷！


71. Simplify Path
https://leetcode.com/problems/simplify-path/#/description
比较简单一道string和stack结构结合的题目，一刷没有AC，由于判断语句写错CE。再刷！二刷没有一次AC，本来觉得挺简单的，还是各种漏洞！getline函数的第三个大叔是一个char型，表示分隔符，因为这个写错导致CE；因为逻辑出错导致RE。三刷一次AC。


93. Restore IP Addresses
https://leetcode.com/problems/restore-ip-addresses/#/description
DFS的题，不是很难，但是没思路。一刷废了很大劲没AC。思路也没太理清楚，再刷！二刷没有一次AC，DFS理解的还是不透彻，循环结构中不应该改变can参数，只在向更深层传递参数的时候改变参数！再刷！


22. Generate Parentheses
https://leetcode.com/problems/generate-parentheses/#/description
一道简单的递归题，但是没想出来。一刷AC，但是思路不是自己的，再刷！




















