463. Island Perimeter
https://leetcode.com/problems/island-perimeter/
就是逐一遍历所有的cell，用分离的cell总的的边数减去重叠的边的数目即可。在查找重叠的边的数目的时候有一点小技巧，就是沿着其中两个方向就好，这种题目都有类似的规律，就是可以沿着上三角或者下三角形的方向来做。一刷一次ac，但是还没开始注意codestyle的问题，需要再刷一遍。


455. Assign Cookies
https://leetcode.com/problems/assign-cookies/
给出两个序列，一个序列中的元素代表cookie的size，另外一个序列代表能满足孩子要求的最小cookie的size，问如何分配使得到的满意的孩子最多。先将两个序列都按从小到大顺序排序，然后按双路指针的方式解决。一刷一次ac，但是对于C++默认的sort函数的排序方式（从小到大还是从大大小）并不是很清楚。
算法库中的sort(beg, end, comp)函数实际使用快排，其中的comp是函数或者函数指针，签名是 bool comp(elem_type first_arg, elem_type second_arg)，返回的bool值的含义是第一个参数是否应该排在第二个参数的前面。而且默认参数会将较小的参数排在前面，即sort函数默认是从小到大排序！


453： Minimum Moves to Equal Array Elements
https://leetcode.com/problems/minimum-moves-to-equal-array-elements/
一开始自己对题目的理解出错了，浪费了不少时间。每次移动要求同时将n-1个元素加1，我看成了每次移动将其中2个元素加1。搞清楚题目真正含义之后，不太会做，参考了一下其他人的解题思路：给数组中的n-1个元素加1的操作等价于数组中“不加1的那个元素“减去1，然后数组中的所有元素都加1。我们知道，给所有的元素都加1并不能改变原数组中的数之间的差值。所以这题就转化为求最少的减1操作。而要使数组中的元素全部相等，又要使用减法。那么最少的次数就是让这些元素全部都等于数组中最小的数。所以得到的结果就是sum（所有元素和）-n*数组中最小元素。
注意看题目！一刷由于c++的api用的不熟。


383. Ransom Note
https://leetcode.com/problems/ransom-note/
就是用后一个串合成前一个串，条件是后一个串的每个字符只能用一次，这种题都可以利用c++的字符和int型转换来构建一个长为26的数组，每个数组表示一个key（前提是全大写或者全小写）。
一刷for循环中的计数器i没有声明类型（int），编译错误。二刷一次ac。



404. Sum of Left Leaves
https://leetcode.com/problems/sum-of-left-leaves/
看到这种题知道用递归，但是自己的思路很长时间没有理清。递归算法只要想明白一个节点的情况，其他节点都一样。对于每个节点如果指针为空，返回0；如果该节点飞空且左子树为叶子节点，则返回左叶子节点和右子树递归结果的和，否则返回左右子树的递归结果的和。一刷在处理左子树为叶子节点的情况时少写了val，二刷一次ac。

还有一种写了两个函数的算法，其实差不多。一刷第一次调用dfs函数参数给错了，只有一个root节点不算左叶子结点。二刷出现不明bug……没解决！

递归算法虽然简单明了，缺点是低效。尝试非递归算法，但是效率并没有提升，可能是因为递归与非递归算法用的是相同的原理：栈。一刷没有处理root为空的情况，忘记写返回语句。二刷也没有处理root为空的情况，另外没有声明类型，并且把变量名混淆。三刷处理了root为空的情况，但是处理栈顶元素的时候直接处理栈顶元素，其实应该处理栈顶元素的左右结点。四刷一次ac。


409. Longest Palindrome
https://leetcode.com/problems/longest-palindrome/
比较简单，如果字母个数为偶数，直接加，字母个数为奇数，加上减一后的值，由于回文串中间可以放一个长度为一的子串，因此如果有个数为奇数的字母，最后结果要加一。
一刷统计小写字母的出现次数时，条件写反了。计算最后结果时注意处理出现次数为奇数的字符。二刷一次ac。


448. Find All Numbers Disappeared in an Array
https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/
要求不能使用额外空间，只能在原数组上进行改动，将提到的元素对应的索引上的值加上负号，对后续的遍历操作影响不大（取绝对值就行）。由于在遍历到i之前已经将i后到元素置为负值，因此要在遍历到时候就加上绝对值。一刷中括号写成了小括号（取数组元素写成了函数调用，这两者的区别大了），在加入结果的时候少写了if语句。二刷一次ac。


442. Find All Duplicates in an Array
https://leetcode.com/problems/find-all-duplicates-in-an-array/
题目和上面那道题差不多，而且更简单！可是我没想到。和上一题的区别在于在处理重复赋值时直接就加入结果队列了。一刷一次ac。


414. Third Maximum Number
https://leetcode.com/problems/third-maximum-number/
找出n个数中的第m（m < n）大的数，这是个经典问题，我去望京面试的时候就被问到，我当时真菜，不然暑假可以拿好多钱，哼！当m不太大（m<4）时，都可以按同一种思路解决 ，就是同时设置多个max，遍历数组元素，分条件更新max。注意两点，一是max的初始化一定要比当前数组元素类型的最小值要小；二是max更新条件要写全，“=”的情况要排除。
一刷各max的更新顺序写反了，max更新条件没写全，没有用更大范围的数据类型。二刷一次ac。


289. Game of Life
https://leetcode.com/problems/game-of-life/
一刷判断自身的条件写错，死而复生的判断条件写错，代码效率不高。二刷代码结构有优化，但是效率还是不高，判断语句中==写成赋值号=，cell周环遍历数列写错（1写成-1）。三刷没有ac是因为不理解c++_11新特性。(auto n : vec)中的n是临时变量，修改n不能改变原来vector中的元素，因此在不需要修改vector中元素时遍历可以用auto，但是要修改vector中的元素，还是需要迭代器或者下标。


287. Find the Duplicate Number
https://leetcode.com/problems/find-the-duplicate-number/
一刷使用二分法，但是对二分法中low和high的更新细节不清楚，多个同类型的变量一起声明时应该用逗号隔离。二分法中low与high的更新过程和后面的返回值是low还是mid又有什么关系，还需要一点时间来理解。看了大神的博客知道发现更高效的算法，就是转化为链表内部环检测的问题。链表成环检测的问题是一个经典问题，大神的博客分析非常精彩，核心思想是用快慢指针走过的路程和环长等进行推理和证明，最后一个恒等式的利用非常精彩。大神博客地址为：http://www.cnblogs.com/ccdev/archive/2012/09/06/2673618.html,二刷使用该方法一次ac。


2. Add Two Numbers
https://leetcode.com/problems/add-two-numbers/description/
链表。


24. Swap Nodes in Pairs
https://leetcode.com/problems/swap-nodes-in-pairs/description/
一次走两步。注意原链表只有一个元素时新链表为空，要对这种情况进行判别。


268. Missing Number
https://leetcode.com/problems/missing-number/
一开始掉进了前面的解法的坑里，老想着把元素当作索引，将正值变负值，然后找改变后的数组中的正值对应的元素，由于同时有n和0，这两种情况不能有效区分，而且也没说可以改动数组，故抛弃了这种解法。求和再做减法更方便，由于担心溢出，用了范围更大的数据结构，好像没什么用。


229. Majority Element II
https://leetcode.com/problems/majority-element-ii/
看了一篇博客，恍然大悟，很开心，就喜欢这种感觉。原博地址：http://blog.neoshell.moe/leetcode229.html
简而言之就是BM多数投票算法（Boyer-Moore Majority Vote algorithm）。代码效率好像不高，还要找找更高效的算法。一刷很快ac，二刷一次ac。
要注意变量的初始化，将n1，n2初始化为任意两个不同的数就行，对应counter设置为0是关键。还要注意一点第一次遍历结束只是明确了n1，n2是出现频率最高的数，但是对应的counter是不准的，需要重新计数！最后需要查看counter是否满足条件。


228. Summary Ranges
https://leetcode.com/problems/summary-ranges/
题目不难，需要注意变量的初始化和主循环之后的操作。记得返回处理结果！一刷算法效率不高，但是这是自己的思路，虽然代码写完之后自己也无法复现完整的思维过程。一开始思路不清晰，先写了一些不成熟的代码，然后不断修补，最后即使ac，思路已经支离破碎！还是需要完整而简洁的思路，如果自己没有这种思路，就去找优美的思路，然后逐行理解，把大神的思路变成自己的！
二刷我找到了一篇大神的博客，代码简洁而且思路清晰。用b记录本次范围的起始位置，用i作为索引。注意更新i和b时先更新i再更新b，而且是拿第i个元素和第i+1个元素比较，这样就不必在循环体外单独处理最后一个元素了！这点经验非常宝贵！三刷一次ac。


216. Combination Sum III
https://leetcode.com/problems/combination-sum-iii/
一刷使用dfs解决。我总是不太会构造递归，要注意这种题型！用递归解决问题，只要关注解决本层次的问题就好，通过条件筛选和循环将本层解决完，调用本身进入下一层。这种说法很简单，其实不容易做到！
注意剪枝条件，比如left可能等于i，每步循环中，需先将元素插入列表尾部，在下一层递归结束后，要将插入的元素从尾部取出！


547. Friend Circles
https://leetcode.com/problems/friend-circles/description/
一刷使用DFS，也可以使用并查集解决。


721. Accounts Merge
https://leetcode.com/problems/accounts-merge/description/
一刷使用DFS，C++版debug很久，用python写debug方便很多，但是超时了。二刷使用并查集。上面那道题是并查集的简单题，这道属于并查集比较难的题。


720. Longest Word in Dictionary
https://leetcode.com/problems/longest-word-in-dictionary/description/
Trie和DFS结合，一次AC。


677. Map Sum Pairs
https://leetcode.com/problems/map-sum-pairs/description/
Trie和BFS结合，一次AC。


743. Network Delay Time
https://leetcode.com/problems/network-delay-time/description/
一刷使用DFS没AC，debug很久,没理解错哪了，二刷使用BFS就AC了。三刷使用Dijkstra算法，效率不如BFS，实现效率不高，可以继续改进。BFS是Dijkstra的降级。
原来leetcode后端是用python写的！以后用pycharm写python或者intelij idea写java来debug也不错！


542. 01 Matrix
https://leetcode.com/problems/01-matrix/description/
一刷使用朴素的BFS一次AC，二刷加了一点trick，in-place的方式，题目要找到所有格到0格的最短距离，从0格出发不断修改到达非0格的距离，这种转换在DFS和BFS类的题目中非常常见！时间复杂度？？


417. Pacific Atlantic Water Flow
https://leetcode.com/problems/pacific-atlantic-water-flow/description/
一刷使用相反的方式，从内到外查看一个节点是否能到达P或者A，终止条件不对，debug很久。二刷使用由外到内的方式，没理解终止条件中的mark参数的意义。

209. Minimum Size Subarray Sum
https://leetcode.com/problems/minimum-size-subarray-sum/
一开始把题目意思理解错了，浪费了很多时间。subarray是原array的连续子序列，就像substring是原string的连续子序列一样。基于错误的理解，我使用dfs来解决，后来超时才反应过来。一定要好好看题，正确理解题意，往往事半功倍！正确地理解了题意之后，一刷很快ac。二刷更新min_size时没有判别，代码有小幅更新（能用while就不要用for）。
用sum和left记录当前subarray的和与起始位置，注意同时更新sum和left，每次更新min_size之前需要对当前subarray的size进行判别。


162. Find Peak Element
https://leetcode.com/problems/find-peak-element/
一刷使用直接遍历的方法，很笨，写了一半发现可疑从两头一起开始遍历，但是时间复杂度并没有明显改善。二刷使用基于迭代的二分法，二分法的合理性感觉可以用罗尔定理证明。变量名写错，mid的判断条件写错。
以后就把自己的二分法固定下来，while里面填low < high, 更新方式为high = mid， low = mid + 1， 返回low。这样以来，写代码的时候实际要判断的只有更新条件了！


二分法还可以用递归的方式表现。


154. Find Minimum in Rotated Sorted Array II
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/
原来algorithm库中是有min（max）函数的，也有min(max)_element函数的！但是min（max）函数只接受两个参数，没什么实用价值，min(max)_element函数也没什么大的使用价值，返回迭代器。
其实比较简单，一刷一次ac。说实在的，自己被这个hard标志吓得不轻。

153. Find Minimum in Rotated Sorted Array
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
和154一模一样。


152. Maximum Product Subarray
https://leetcode.com/problems/maximum-product-subarray/
原理是dp，但是我对dp并不熟！关键在于当前的max和min并不是全局的max和min，每遍历一个元素就要更新全局的max（res）。一刷变量名写错，效率也不高。二刷由于不理解DP，更新过程写错！三刷一次AC。



344. Reverse String
https://leetcode.com/problems/reverse-string/
字符串翻转，很简单。使用内置函数swap简化了代码，一次AC。


136. Single Number
https://leetcode.com/problems/single-number/
位运算（异或）经典题目。想象一个多层公寓，每个公寓住着0或者1，异或像如来神掌一样将每一位从上而下压缩。


137. Single Number II
https://leetcode.com/problems/single-number-ii/description/
每一位都有规律，仍然可以按照上题的思路思考，每一位上都是这样的规律sum = x_1 * 3 + x_2 * 3 + ... + x_n-1 * 3 + y，要得到y对sum模3即可。


260. Single Number III
https://leetcode.com/problems/single-number-iii/description/
位操作，按第一个不同的位将nums分为两派即可。思路同前两道题。


461. Hamming Distance
https://leetcode.com/problems/hamming-distance/description/
位运算，与和异或。


477. Total Hamming Distance
https://leetcode.com/problems/total-hamming-distance/description/
位运算，分两派，该位为0和该位为1，分别记录每派的count，相乘加到结果上即可。


190. Reverse Bits
https://leetcode.com/problems/reverse-bits/description/
位运算。一刷边界设置错误没AC。


201. Bitwise AND of Numbers Range
https://leetcode.com/problems/bitwise-and-of-numbers-range/description/
位运算


405. Convert a Number to Hexadecimal
https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/
位运算，注意0的问题，算术右移和逻辑右移的区别。


421. Maximum XOR of Two Numbers in an Array
https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/
位运算比较难的题，没太明白关键一步异或的操作的含义。再刷。


7. Reverse Integer
https://leetcode.com/problems/reverse-integer/description/
和190相似，一刷没AC。注意考虑极限情况，包括INT_MAX和INT_MIN。


476. Number Complement
https://leetcode.com/problems/number-complement/description/
位运算，求补码，从符号位开始0变为1，然后取反。


342. Power of Four
https://leetcode.com/problems/power-of-four/description/
位运算，搞了很久，没抓住主要性质。


318. Maximum Product of Word Lengths
https://leetcode.com/problems/maximum-product-of-word-lengths/description/
位运算，一刷做的不是最优解！


104. Maximum Depth of Binary Tree
https://leetcode.com/problems/maximum-depth-of-binary-tree/
一刷使用层序遍历（BFS），一次AC，效率不高。二刷使用DFS，一行解决问题，效率也非常高，一次AC。


389. Find the Difference
https://leetcode.com/problems/find-the-difference/
对于字符串的常用方法，将字符转为数组下表，从而将空间复杂度降到O(N)。二刷一次AC。


226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
使用递归，较简单，二刷一次AC。


169. Majority Element
https://leetcode.com/problems/majority-element/
二刷使用BM投票算法，因为初始化错误没能AC，深层原因在于没能透彻理解BM算法。


100. Same Tree
https://leetcode.com/problems/same-tree/
使用递归，教简单，二刷改善了codestyle，逻辑也更清晰，一次AC。


128. Longest Consecutive Sequence
https://leetcode.com/problems/longest-consecutive-sequence/
HashMap，空间换时间。可以使用师姐的思路，每次遇到没访问过的元素，访问之，并查看该元素所在最长连续序列的长度，更新结果，O(N^2)。使用unordered_map记录访问元素的最大长度。当n-1和n+1都访问过后，将序列两端的元素对应的最大长度更新。因为之后序列内部的元素就不考虑了，只会考虑序列外的元素，而序列外的元素跟该序列可能链接的地方只有左右两端，这个题很像DP，注意要将该元素设为访问过的状态，要向map中添加pair，O(N)。


126. Word Ladder II
https://leetcode.com/problems/word-ladder-ii/
使用BFS，代码非常复杂，这道题确实很难，通过率仅13%！需要考虑的东西很多，看大神的代码看了3天才算弄明白怎么回事。还是要动笔自己跑几个demo，这样非常有助于了解算法的精妙之处。大神的代码是用java写的，我把它翻译成了C++，也挺有难度的！一刷在XCODE上写的，debug花了不少时间，不过这样一来对C++的容器的使用更熟练了。非常关键的一点在于不能重复向队列中插入元素！二刷有两处语法错误，一个函数签名写错（少写了一个引用符号），导致返回结果为空，比起一刷进步很大，非常开心。三刷一次AC，写的时候细心一点，还是可以一次AC的！


121. Best Time to Buy and Sell Stock
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
比较简单，但是看了一会没什么思路，看了discuss区的答案。思路是遍历每天的股价，记录今日之前的最低价和最高收益，和今日股价比较更新最低价，最高收益和今天卖出的收益比较更新。一刷一次AC，但是思路不是自己的！


120. Triangle
https://leetcode.com/problems/triangle/
DP，从底向上找。一刷for循环里面的变量名写错，也是醉。这种算法的空间复杂度为O(N)，还有一种空间复杂度为O(1)的算法，下次来的时候好好调研一下。


105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
递归。


106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
递归。同105，由于树中无重复元素，可以用map记录inorder中元素到index的映射，这样就不用在生成树时遍历inorder查找元素了，这样可以把时间复杂度降为O(N^2)。


108. Convert Sorted Array to Binary Search Tree
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/
递归，二分查找。


109. Convert Sorted List to Binary Search Tree
https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/#/description
同108，只是这里mid要通过快慢指针来找。


114. Flatten Binary Tree to Linked List
https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/
递归，将左右分别flattern之后，将左侧链接到右侧。


80. Remove Duplicates from Sorted Array II
https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
比较简单，将重复次数小于3的元素往前移动，其他元素不动，就得到了重复次数最多为2的元素的个数。一刷题目理解不清，循环条件写错。二刷循环条件写错。三刷一次AC。


75. Sort Colors
https://leetcode.com/problems/sort-colors/
这道题是让手写排序，一刷手写快排没AC。二刷由于多次将左侧边界想当然地视为0（其实是l）没能AC。讨论区第一名的算法针对特殊情况（只有0， 1， 2三个数字）对普适的排序算法做了优化，一刷循环条件写错没AC。二刷思路不清晰，没AC，注意需要两层循环，内层循环只处理连续的符合条件的情况，外层需要等于因为该index对应的值谁也不知道是几。第二种算法的在时间效益上不如快排。


74. Search a 2D Matrix
https://leetcode.com/problems/search-a-2d-matrix/?tab=Description
BS，将矩阵降为视为一维数组用BS。index的映射关系:matrix[mid / n][mid % n]。


73. Set Matrix Zeroes
https://leetcode.com/problems/set-matrix-zeroes/?tab=Description
将第一行第一列作为标志，第一行第一列用其他标志。顺序遍历将标志置0，逆序遍历按标志将元素置0。算法复杂度高些，但是好理解。


62. Unique Paths
https://leetcode.com/problems/unique-paths/?tab=Description
DP。


63. Unique Paths II
https://leetcode.com/problems/unique-paths-ii/?tab=Description
DP。同62。


64. Minimum Path Sum
https://leetcode.com/problems/minimum-path-sum/?tab=Description
DP。同62。


53. Maximum Subarray
https://leetcode.com/problems/maximum-subarray/?tab=Description
DP，可以降为0维DP。累加，当加到a[i]时候如果当前sum小于0。就把[0-i]都扔掉 重新加起。画了个函数图像，感觉稍微好些。序列中的每个数都是sum的导数，这么看的话就可以理解。DP算法好些可以解释连续的问题。和LCS很相似，DP解法构造子问题形式的思路相同，DP[i]表示以[i]结尾的sub序列。


72. Edit Distance
https://leetcode.com/problems/edit-distance/description/
DP，知道思路，没能将问题降级为子问题。需要继续理解！


486. Predict the Winner
https://leetcode.com/problems/predict-the-winner/description/
二维DP，一维亦可，二维DP易于理解。两个维度坐标含义相同，填表方式是沿对角线填表，这取决于子问题的结构。子问题比较容易看出来，对于dp[i][j],取头剩dp[i+1][j],取尾剩dp[i][j-1]，但是剩下的是对手的盘，因此要将dp中存储的元素设置为一手比二手玩家多得的分，这样对手的盘就是负值！


59. Spiral Matrix II
https://leetcode.com/problems/spiral-matrix-ii/?tab=Description
挺有意思的一道题，开始我以为矩阵有两种分解方式：第一种很有美感，结果这是个陷阱，n为偶数时可以正确返回结果，当n为奇数时，矩阵最中间的那个格会形成死循环；第二种才是正确的分解。一刷嵌套式vector的初始化语法写错，没能AC。二刷循环中更新j出错，没能AC。


56. Merge Intervals
https://leetcode.com/problems/merge-intervals/?tab=Description
sort的第三个参数为重载了"<"的函数，可以自己写myCompare函数实现"<"逻辑，也可以写函数类用于构建函数对象。也可以利用C++11新特性lambda表达式实现，编译器会根据lambda表达式生成函数对象。


57. Insert Interval
https://leetcode.com/problems/insert-interval/description/
同56，先将要新Interval插入列表，然后merge。应该有更高效的算法。


55. Jump Game
https://leetcode.com/problems/jump-game/?tab=Description
看了讨论区的两个算法，一个很简洁，4行完事，思路是遍历每个元素，看每个元素当前能达到的最远处是否包括当前元素（本质是0能不能跳过），一刷AC。另一个效率高些，思路更清晰，就是看0元素能不能跳过去，一刷没AC，注意循环从倒数第二个元素开始，因为最后一个元素的值是不用考虑的。二刷思路错了，不应该比较sum和dis，而应该比较dis和相应位的num，没能AC。但是这次刷理解了中间cur为什么可以直接减。


54. Spiral Matrix
https://leetcode.com/problems/spiral-matrix/?tab=Description
按照59题相似的思路，出现了两个比较大的BUG，一是内层while循环索引没有递增/减，二是在两次反向遍历的时候要加一个判断条件，以免与正向遍历的是同一行/列。一刷没AC。二刷写错了最后一次从下向上遍历过程的行的index的初始化值，没能AC，但是对代码进行了优化。



48. Rotate Image
https://leetcode.com/problems/rotate-image/?tab=Description
采用讨论区第一名的算法，效率不是很高，但是很容易明白。是一种普适的方法。对于旋转先将矩阵进行行逆序，然后对角互换。对于逆时针旋转则是先进行列逆序。一刷AC。二刷一次AC。


35. Search Insert Position
https://leetcode.com/problems/search-insert-position/?tab=Description
BS。可以直接用upper_bound或者lower_bound来做。


34. Search for a Range
https://leetcode.com/problems/search-for-a-range/?tab=Description
BS。BS查找下界和上界两类问题存在区别，区别在于求下界时mid要靠近low，求上界的时候mid要靠近high；这种区别决定在每次循环更新要找的那个界限（low或者high）。也可以借助STL的upper_bound和lower_bound函数实现。


33. Search in Rotated Sorted Array
https://leetcode.com/problems/search-in-rotated-sorted-array/?tab=Description
BS。[mid]和[low]比较，是为了确定[mid]在较大的前半部分还是较小的后半部分，[mid]在前半部分的条件就是[low] <= [mid]。


81. Search in Rotated Sorted Array II
https://leetcode.com/problems/search-in-rotated-sorted-array-ii/
BS。同33，只是数组中存在重复元素，[mid] = [low]时分类不明显，直接拎出来，令low++(相当于遍历)，其余不变。


31. Next Permutation
https://leetcode.com/problems/next-permutation/?tab=Description
math。先从后将降序变为升序，然后找升序中前一个数字的上界与该数字替换。


18. 4Sum
https://leetcode.com/problems/4sum/?tab=Description
双指针。先进行sort，然后逐个确定i,j,l,r四个指针，注意去重和剪枝(非必须)。


16. 3Sum Closest
https://leetcode.com/problems/3sum-closest/?tab=Description
和18题非常相近，而且要简单很多。仿照18题的思路写了大部分，结果最后一行更新left和right的时候走入弯道了，看了讨论区的算法有了想法。变量名写错，三目运算符写错，一刷没能AC。二刷变量n没有声明，没有AC。


15. 3Sum
https://leetcode.com/problems/3sum/?tab=Description
15，16，18思路一样，但是都没有一次AC。一种算法，在不理解的情况下，至少要写5次才能懂得每一步的精髓！一刷去重条件写错，没能AC。二刷一次AC。


11. Container With Most Water
https://leetcode.com/problems/container-with-most-water/?tab=Description
一开始理解错题意，把矩形当成梯形来算，看了讨论区算法的思路后，自己写出来的。一刷AC，但是还需要再刷。二刷迭代时没有更新结果，没能AC。三刷连思路都没了，花了很长时间。我的思路是选可能留下的，而这种情况并不容易搞，答案是筛去不符合的！这样就简单很多。还要再刷！！


535. Encode and Decode TinyURL
https://leetcode.com/problems/encode-and-decode-tinyurl/#/description
比较简单的一道题，但是就是没思路，好烦，做的题还是不够多，很多C++的STL操作都忘掉了，上周写了不少python之后，现在写C++老是忘记写；在不同的语言之间来回切换容易精神错乱！一刷没AC。


508. Most Frequent Subtree Sum
https://leetcode.com/problems/most-frequent-subtree-sum/#/description
不算难，现在衡量难与不难的标准是看了有没有思路。有思路但是花很长时间肉眼debug才A掉这个题。而且思路没有简化到极致。最大的那个count可以在遍历树的过程中找到，我是遍历完树之后再遍历map找的，map中的元素可以自动初始化，这种情况和python不一样，不用判断键是否存在！经过优化之后，代码非常简洁而且效率提高了一倍。一刷没有AC！二刷没有一次AC，注意iterator的操作不能使用<，只能使用!=和=。


1. Two Sum
https://leetcode.com/problems/two-sum/description/
multimap存储去掉一个数之和的target，遍历数组查找是否有数字。


500. Keyboard Row
https://leetcode.com/problems/keyboard-row/#/description
现在连easy级的题都没法一刷AC了，真是菜啊！再刷！！！二刷一次AC。


454. 4Sum II
https://leetcode.com/problems/4sum-ii/#/description
没有思路，要再刷两遍！一刷没AC，res更新不是加1，而是加上map中的count！二刷一次AC，但是思路理解并不流畅！还要再刷!


451. Sort Characters By Frequency
https://leetcode.com/problems/sort-characters-by-frequency/#/description
比较简单，但是比较考基本功，但是还是不明白为啥要用static关键字！！！一刷没AC，注意map使用[]操作查询时，不存在的键会自动生成！而值会调用相应的默认构造函数！这是c++的一大优点。


438. Find All Anagrams in a String
https://leetcode.com/problems/find-all-anagrams-in-a-string/#/description
没思路，一刷没AC，注意滑动窗口，这是个等大小的窗口，只是用vector而不是用map的算法效率不高。


380. Insert Delete GetRandom O(1)
https://leetcode.com/problems/insert-delete-getrandom-o1/#/description
一刷没AC，注意get_random的时候index不能为0！


274. H-Index
https://leetcode.com/problems/h-index/#/description
一刷没思路！注意vector和Hashmap的查找复杂度都是O(1)！开数组，多加一个元素用于存储引用数大于size的个数。


166. Fraction to Recurring Decimal
https://leetcode.com/problems/fraction-to-recurring-decimal/#/description
一刷没AC，磕磕碰碰，花了很长时间，但是最后肉眼debug成功了。再刷！ 注意极端情况如0，如负数，还有超出界限的问题。效率不高。
discuss区c++第一名的算法非常简洁，和我思路一样。


138. Copy List with Random Pointer
https://leetcode.com/problems/copy-list-with-random-pointer/#/description
一刷没AC，但是按照自己的思路最后还是debug成功了，再刷！！对链表的更新过程不熟悉，使用一个hash表记录已经访问过的节点。


94. Binary Tree Inorder Traversal
https://leetcode.com/problems/binary-tree-inorder-traversal/#/description
二叉树的前、中、后遍历的递归和非递归算法都要很熟悉。


49. Group Anagrams
https://leetcode.com/problems/anagrams/#/description
map使用红黑树实现，而unordered_map基于hash table，使用hash型数据结构必须保证key的类型有hash()方法，容器类型除了string外默认是没有hash()方法的，而非hash型数据结构没有限制！c++中对于map和unordered_map，使用[]方法访问当key不存在时调用value的默认构造函数。


445. Add Two Numbers II
https://leetcode.com/problems/add-two-numbers-ii/#/description
很简单，但是没有一次AC！而且我的方法时间和空间复杂度都比较高。


328. Odd Even Linked List
https://leetcode.com/problems/odd-even-linked-list/#/description
很简单的一道题，题意理解错误，正确理解题意后一次AC。


148. Sort List
https://leetcode.com/problems/sort-list/#/description
对排序还是有点怵，没思路，看了归并排序的思路自己写没有一次AC，漏掉了merge步骤更新h。再刷！！


147. Insertion Sort List Add to List
https://leetcode.com/problems/insertion-sort-list/#/description
比较简单，一刷没AC，查找插入位置时应该从h->next开始，而不应该冲h开始！


143. Reorder List
https://leetcode.com/problems/reorder-list/#/description
挺简单的，看了就有思路，算法还不错，没有一次AC，再刷！借用上一题的思路，用双指针分离，将后段逆序，之后merge。注意merge阶段保存的是插入进来的node！


19. Remove Nth Node From End of List
https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/
双指针，先将快指针定位到n + 1处，维持快慢指针的间隔，直到快指针到了fast处，将慢指针后面的节点删除。注意要使用dummy节点作为新的头结点。


26. Remove Duplicates from Sorted Array
https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/
双指针。

27. Remove Element
原地操作，删除数组中的固定值的元素。
双指针。


142. Linked List Cycle II
https://leetcode.com/problems/linked-list-cycle-ii/#/description
链表成环检测。快慢指针，快指针每次走两步，慢指针每次走一步，如果两者相遇则有环。此时令快指针从头开始走，快慢指针一次走一步，知道两者相遇，相遇点就是环的起点。


206. Reverse Linked List
链表反转，头插法。


92. Reverse Linked List II
https://leetcode.com/problems/reverse-linked-list-ii/#/description
链表部分反转，头插法。


25. Reverse Nodes in k-Group
https://leetcode.com/problems/reverse-nodes-in-k-group/description/
链表分组反转，头插法。使用pre和cur分别记录当前组和下一组的头结点，设置dummy node作为结果链表的起始，记录新链表的尾部，因为没插入一个新的组之后就要更新这个尾部，再进行头插法。


61. Rotate List
https://leetcode.com/problems/rotate-list/#/description
比较简单，一刷没有AC，思路有一点错误，不应该直接把旋转点之后的节点直接使用头插法，对k也要非常注意，k可能超出length。总结一点：如果链表中head不稳定，可能变化，就要另外设置一个新的head！二刷一次AC。


83. Remove Duplicates from Sorted List
https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/
双指针。用pre和cur两个指针，cur走到cur和cur->next不等，pre = cur，pre=cur->next, cur=cur->next。


82. Remove Duplicates from Sorted List II
https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/#/description
双指针。同83，记录cur重复次数次，重复一次pre = cur，重复多次pre ->next = cur->next。最后cur=cur->next。


86. Partition List
https://leetcode.com/problems/partition-list/#/description
双指针。设置两个dummy node对于两部分分别进行尾插法，形成两个链表然后接上。


523. Continuous Subarray Sum
https://leetcode.com/problems/continuous-subarray-sum/#/description
思路不是自己的，一刷没AC，因为变量写错CE，因为没考虑K会是负数而WA，还要再刷！


462. Minimum Moves to Equal Array Elements II
https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/#/description
这个问题中数列的平衡杆不一定就是均值，因为经过排序后两端每对数字移动的总距离和均值无关。当数字有偶数个时，以均值直接算作平衡杆正确；当数字有奇数个且中间那个数恰好为均值时，用均值作为平衡杆也正确；但是当中间那个数不是均值时，就应该用中间那个数作为平衡杆，亦即中间那个数不需要移动！
一次AC，但是思路不是自己的，还要再刷！


441. Arranging Coins
https://leetcode.com/problems/arranging-coins/#/description
很简单的数学问题，就是个一元二次方程求解的问题，我忘记用公式了。用了个O(long N)的方法，用公式一次一次开方就OK了。一次AC。


423. Reconstruct Original Digits from English
https://leetcode.com/problems/reconstruct-original-digits-from-english/#/description
比较简单的多元方程组的问题，一刷没AC，因为string和int的互换方法不清CE了，算法效率也不是很高。


415. Add Strings
https://leetcode.com/problems/add-strings/#/description
很简单，看了就有思路，一次AC。算法效率好像不太行。


400. Nth Digit
https://leetcode.com/problems/nth-digit/#/description
思路不是自己的。一刷没AC，因为base设为int类型越界导致WA。再刷！


413. Arithmetic Slices
https://leetcode.com/problems/arithmetic-slices/#/description
比较简单，一刷没有AC，不用设置两个begin和end两个变量，只需一个middle就可以了，注意middle从1到A.size() - 2，因为这个WA。因为==写成=CE。


372. Super Pow
https://leetcode.com/problems/super-pow/#/description
思路不是自己的，一刷AC，还要再刷！递归设计的很好！


368. Largest Divisible Subset
https://leetcode.com/problems/largest-divisible-subset/#/description
思路不好，有漏洞，看了讨论区的C++算法，一刷没AC。因为开始没对数组没排序得了WA。对大神的思路理解的不够深入，再刷！！


367. Valid Perfect Square
https://leetcode.com/problems/valid-perfect-square/#/description
一道简单的二分查找，一刷没有AC。注意一个公式1 + 3 + 5 + 7 + 9 + …… = n^2!因为mid设为int，结果溢出得了WA。


365. Water and Jug Problem
https://leetcode.com/problems/water-and-jug-problem/#/description
巨硬笔试题，数论问题，挺难的！证明还挺复杂……。最大公约数GCD和最小公倍数LCM还不太会弄！一刷一次AC。但是思路理解起来还是挺费劲的！再刷！


343. Integer Break
https://leetcode.com/problems/integer-break/#/description
一道规律题，一刷没有AC，以为大于号写成小于号得了WA，需要用导数来推导，果然是数学题！再刷！


319. Bulb Switcher
https://leetcode.com/problems/bulb-switcher/#/description
规律题，发现了一部分规律，但是没有继续深入，发现的规律还比较浅层。一刷一次AC。


69. Sqrt(x)
https://leetcode.com/problems/sqrtx/#/description
二分法注意0和mid * mid == x的情况。经典方法是Newton法。


313. Super Ugly Number
https://leetcode.com/problems/super-ugly-number/#/description
比较复杂，我有个思路，但是没有想到怎么实现。看了讨论区算法才搞明白，思路不是自己的，一次AC，还要再刷！


279. Perfect Squares
https://leetcode.com/problems/perfect-squares/#/description
没思路，讨论区使用的是DP算法，还有一种数学算法，不太懂，放弃了！一刷没有AC，变量没有定义拿了CE！再刷！


264. Ugly Number II
https://leetcode.com/problems/ugly-number-ii/#/description
和313题很像，我也是用的313题的方法，效率还不错，一刷AC。


50. Pow(x, n)
https://leetcode.com/problems/powx-n/#/description
使用进制计算，计算n的2进制表示下的每一位的权值并相乘。注意将n由负转为正时，需要使用long long类型。


60. Permutation Sequence
https://leetcode.com/problems/permutation-sequence/#/description
题目不简单，看别人的代码很难，对思路还不是很清晰，再刷！


43. Multiply Strings
https://leetcode.com/problems/multiply-strings/#/description
大数乘法。从低位到高位，对于结果的每一位都跑一次循环，得到该位的数字并设置全局变量记录进位。初始化结果全零，之后再将高位的0抹去，当结果为0要补个0。


29. Divide Two Integers
https://leetcode.com/problems/divide-two-integers/#/description
二进制，位运算。时间复杂度是O(logN)。


12. Integer to Roman
https://leetcode.com/problems/integer-to-roman/#/description
自己建立map，将阿拉伯数字与罗马数字字符串对应起来。

13. Roman to Integer
https://leetcode.com/problems/roman-to-integer/description/
是12题的逆过程。

567. Permutation in String
https://leetcode.com/problems/permutation-in-string/#/description
一个简单的滑动窗口的题目，没思路，真是菜！一刷AC，还要再刷！


532. K-diff Pairs in an Array
https://leetcode.com/problems/k-diff-pairs-in-an-array/#/description
很简单，没有一次AC，再刷！


524. Longest Word in Dictionary through Deleting
https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/#/description
思路不是自己的。一刷因为多个变量在同一行中定义写法出错拿个CE！对于pj的增长方式还是没办法提出比较容易理解的模型。再刷！！


3. Longest Substring Without Repeating Characters
https://leetcode.com/problems/longest-substring-without-repeating-characters/#/description
滑动窗口，双指针。使用一个长为256的vector记录每个char上次出现的位置，用start记录当前无重复元素子串的起始位置，窗口右侧遇到一个已经访问过的char，窗口左侧（start）移到改char上次出现位置的后一位。


557. Reverse Words in a String III
https://leetcode.com/problems/reverse-words-in-a-string-iii/#/description
面试被难倒的一个问题，一刷没有AC，真是辣鸡！再刷！


520. Detect Capital
https://leetcode.com/problems/detect-capital/#/description
一次AC。注意判断逻辑顺序。


541. Reverse String II
https://leetcode.com/problems/reverse-string-ii/#/description
一刷AC。


434. Number of Segments in a String Add to List
https://leetcode.com/problems/number-of-segments-in-a-string/#/description
一刷临界情况没写准，没AC。


551. Student Attendance Record I
https://leetcode.com/problems/student-attendance-record-i/#/description
一刷AC。


459. Repeated Substring Pattern
https://leetcode.com/problems/repeated-substring-pattern/#/description
不难，但是我的解法时间复杂度比较高，一刷没AC.解答区有时间复杂度为O(N)的DP算法。


521. Longest Uncommon Subsequence I
https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description
一行完事，但是很绕！再刷！


5. Longest Palindromic Substring
https://leetcode.com/problems/longest-palindromic-substring/#/description
DP解法,先判断是否为回文串，然后更新起始点，O(N^2)。另一种解法遍历每个字符，沿两侧展开，更新起始点和最大长度，O(N^2)。


9. Palindrome Number
https://leetcode.com/problems/palindrome-number/description/
双指针或者看逆数与原数是否相等，注意本题中负数不合法。


385. Mini Parser
https://leetcode.com/problems/mini-parser/#/description
不算简单，用到istringstream，不好理解！子函数对流修改后，父函数要clear()才能得到正确的指针！一刷AC但是不太理解递归，再刷！


6. ZigZag Conversion
https://leetcode.com/problems/zigzag-conversion/#/description
比较简单，一刷没AC，没有认真考虑边界条件。numRows为0直接返回原串即可。


556. Next Greater Element III
https://leetcode.com/problems/next-greater-element-iii/#/description
不难，但是忘记怎么求下一个排列的算法了。标准库有api可以用！再刷！


227. Basic Calculator II
https://leetcode.com/problems/basic-calculator-ii/#/description
istringstream非常好用，可以从中直接读取任意数据类型，读取字符串直接用getline操作。注意用op来对term进行正负修饰，只有第一次读入加号或者减号的时候需要。一刷没思路，二刷term的正负没写对位置。


224. Basic Calculator
https://leetcode.com/problems/basic-calculator/description/
和227相似，稍难主要是括号的处理。使用signs的栈存储当前括号计算结果应该乘上的符号，sign只存储一个数字的符号。上题适合使用stringstream，本题不适合使用stringstream。


17. Letter Combinations of a Phone Number Add to List
https://leetcode.com/problems/letter-combinations-of-a-phone-number/#/description
BFS和DFS都可以做，我更喜欢用bfs.


336. Palindrome Pairs
https://leetcode.com/problems/palindrome-pairs/#/description
想有个好点的算法比较难，还不太理解讨论区大神的算法，一刷没AC。忘记边界拿了WA，再刷！


539. Minimum Time Difference
https://leetcode.com/problems/minimum-time-difference/#/description
一刷没AC，一开始没看懂题意导致WA。看了解答区的算法手写各种CE！再刷！


583. Delete Operation for Two Strings Add to List
https://leetcode.com/problems/delete-operation-for-two-strings/#/description
一刷没有AC，min函数只能比较两个数，编译错误。DP算法不太懂，再刷！！二刷没有一次AC，j初始化错误。没完全理解算法，再刷！自己手动运行了几遍代码，终于搞懂了。dp的元素矩阵表示应该删除的字符个数，最外围那一行和列表示一个串为子串，而另外一个串为空串！但是没动手再刷一次！再刷！三刷一次AC。


468. Validate IP Address
https://leetcode.com/problems/validate-ip-address/#/description
一刷没AC，getline在这个题目中有妙用！题目不难，但是边界条件非常多！坑很多！再刷！


522. Longest Uncommon Subsequence II
https://leetcode.com/problems/longest-uncommon-subsequence-ii/#/description
思路不是自己的，一刷废了很大劲没AC。用了两种方法，直接构造带有cmp函数的map失效，还没弄明白原因！再刷！


91. Decode Ways
https://leetcode.com/problems/decode-ways/#/description
DP,注意处理非法输入。


71. Simplify Path
https://leetcode.com/problems/simplify-path/#/description
string和stack相结合，面试非常容易考！一刷算法没理解透彻WA。二刷没AC，getline函数的第三个参数是一个char，表示分隔符。三刷AC。四刷自己写WA，要注意边界，每种情况的后续操作都有条件：".."要判断栈空；非"."且非".."时要判断字符串是否为空。


93. Restore IP Addresses
https://leetcode.com/problems/restore-ip-addresses/#/description
DFS。count记录ip段数，start记录起始位。


22. Generate Parentheses
https://leetcode.com/problems/generate-parentheses/#/description
dfs，左括号只要有剩余就可以选，右括号只有在已生成的串中左括号多于右括号才可以选。


475. Heaters
https://leetcode.com/problems/heaters/#/description
比较简单，但是没有好的思路。一刷没有一次AC，而是各种CE！再刷！从解答区选择的思路也不是最好的！二刷没有一次AC，不太懂upper_bound和lower_bound的区别拿了WA，再刷！三刷一次AC。


436. Find Right Interval
https://leetcode.com/problems/find-right-interval/#/description
比较简单，很久没刷，手很生，一刷没AC，各种CE，WA和RE，思路是对的，但是时间复杂度太高。解答区的算法很好，值得借鉴，但是思路不是自己的，再刷！


275. H-Index II
https://leetcode.com/problems/h-index-ii/#/description
是274的附加题。题意很难懂，真的很难懂！很久没刷，找找感觉先！一刷各种错误，有CE也有WA，再刷！


378. Kth Smallest Element in a Sorted Matrix
https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/
不算难，但是要找到二分查找中间的判定条件比较困难！看了一遍大神解法之后，一刷AC，但是对算法了解其实没那么深，尤其是如何将一个不在matrix中的值逼近到在matrix中的值。二刷对算法理解更透彻一些，对运算优先级把握不准，得了WA。再刷！


392. Is Subsequence
https://leetcode.com/problems/is-subsequence/description/
不难，一刷AC,O(N)复杂度。Follow up需要二分查找，discuss区有java代码可以研究一下！以后刷可以直接看follow up！


658. Find K Closest Elements
https://leetcode.com/problems/find-k-closest-elements/description/
不太难，一刷没AC，思路大致正确但是实现有些细节错误！对lower_bound和upper_bound理解不太对，导致WA。lower_bound得到第一个不小于val的元素的迭代器，而upper_bound得到第一个大于val的元素的迭代器。判断条件有精妙，没能完全理解。二刷代码不需要写，试着解释了一个问题就是为什么要去掉low，保留high，因为low是有问题的，相当于数轴上的空心点！一定是high离得近，所以最后舍弃了low！注意考虑边界问题，感觉现在有种做高中物理题的节奏了！再刷！！


671. Second Minimum Node In a Binary Tree
https://leetcode.com/contest/leetcode-weekly-contest-48/problems/second-minimum-node-in-a-binary-tree/
不算难，是数组求第N大元素的变形，只是使用的数据结构变了，核心算法思想没变，不难，递归解决，但是花了很长时间！


669. Trim a Binary Search Tree
https://leetcode.com/contest/leetcode-weekly-contest-48/problems/trim-a-binary-search-tree/
不难，简单的递归题。怪自己总是把问题忘难了想。


670. Maximum Swap
https://leetcode.com/contest/leetcode-weekly-contest-48/problems/maximum-swap/
不难，但是我的方法不太好，应该有很好很简单的方法，可以专门研究一下discuss区的好方法！


672. Bulb Switcher II
https://leetcode.com/contest/leetcode-weekly-contest-48/problems/bulb-switcher-ii/
一道规律题，挺难的，没思路，也没有发现规律，讨论区算法很简单，但是不是很理解！需要再理解一下！


222. Count Complete Tree Nodes
https://leetcode.com/problems/count-complete-tree-nodes/description/
很快有思路，但是折腾了2小时，遇到各种错误，而且算法效率非常低！再刷！但是通过这道题更深的理解了二分查找算法。判断条件是更新high还是low只跟mid的计算方式有关，无论什么时候，区间一定要包含答案，这是原则！按照我的书写习惯，low不会比high大，终止情况是low = high = mid！

看了discuss区的算法，就是简单的递归，竟然在效率上打败了50%的算法！！惊呆了！


230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/
一刷计算比mid值小的节点个数时逻辑出错，得了WA，再刷！用VS在本地debug就是方便，终于不用自己写很多cout了，而且快了很多！算法效率不高，follow up没看，后面再刷要注意这两个问题！二刷使用非递归的基于树的中序遍历的方法一次AC，效率高出很多，再刷一次，深入理解BST的中序遍历过程，尤其是非递归方法。


240. Search a 2D Matrix II
https://leetcode.com/problems/search-a-2d-matrix-ii/description/
一刷AC，但是算法效率不高，下次刷要注意这个问题！


401. Binary Watch
https://leetcode.com/problems/binary-watch/description/
一刷没好的思路，看了discuss区之后，发现真的是直接遍历解空间！由于不理解表的的实际运行换算进制搞错得了WA，再刷！


46. Permutations
https://leetcode.com/problems/permutations/description/
dfs, 78，90，46，47，39，40，131，132，77都是简单套路题。面试趋势是这种题目变为解决问题其中的一步。


47. Permutations II
https://leetcode.com/problems/permutations-ii/description/
比46要难，去重可以使用frequency，将重复元素的个数作为重复的第一个元素的访问次数。


90. Subsets II
https://leetcode.com/problems/subsets-ii/description/
一刷去重条件写错，WA。二刷去重条件写错，原数组未排序，WA。


131. Palindrome Partitioning
https://leetcode.com/problems/palindrome-partitioning/description/
先用dp计算任意子串是否为回文，再使用dfs收集合法的partition。


77. Combinations
https://leetcode.com/problems/combinations/description/
dfs。


78. Subsets
https://leetcode.com/problems/subsets/
一刷由于对vector的一些成员函数不熟悉，没有AC。二刷一次AC。讨论区第一名的算法是基于bitmap做的，一刷由于对vector的多元素版本的构造函数格式不熟，没能AC。二刷一次AC。三刷使用backtracing方法刷这类题，效率无损失。递归参数设置错误得了WA，再刷！四刷使用backtracing，没AC，应该存入第i个元素但是存了第start个元素，这个错误好几次了！


39. Combination Sum
https://leetcode.com/problems/combination-sum/?tab=Description
dfs。可以画出解空间来理解解题过程。


40. Combination Sum II
https://leetcode.com/problems/combination-sum-ii/?tab=Description
讨论区第一名的算法先对候选排序，然后使用DFS，搜索路径。注意去除可能重复的路径和并进行必要的剪枝。一刷变量名写错没AC，对去重的理解也只限于想象，没有验证。讨论区第一名算法我添加了剪枝之后，算法执行时间缩短很多，还是挺有成就感的。二刷一次AC。三刷把求解树和递归过程对应上了，理解更简单；剪枝逻辑写错导致剪多了，再刷！


51. N-Queens
https://leetcode.com/problems/n-queens/description/
dfs时让col递增，逐个选择合法的row，存储path，之后将合法path转为棋局排列。注意判断冲突有三个条件（1）row1 ！= row2（2）row1 + col1 != row2 + col2 （3）row1 - col1 != row2 - col2。 


52. N-Queens II
https://leetcode.com/problems/n-queens-ii/description/
dfs，思路同上。


132. Palindrome Partitioning II
https://leetcode.com/problems/palindrome-partitioning-ii/description/
dfs超时,DP一次AC。partition的DP递推公式和判断回文的递推公式不同，[i,j]不满足回文的时候，不能只考虑[i+1,j]和[i,j-1]令其较小值+1，因为[i+1,j]和[i,j-1]虽然可能组成最长的回文子串，也可能partition次数很多！因此要再用一个minCut数组存储最小的cut.


79. Word Search
https://leetcode.com/problems/word-search/description/
dfs。和maze那道题对比，思考想为什么要恢复原状态(回溯)，回溯会不会造成死循环？


89. Gray Code
https://leetcode.com/problems/gray-code/description/
递归。从0开始，不断从起始位或者终止位补0和1(从起始位补的话不必补0，更简洁)，当时从终止位补0或1出错，不知道为啥。


211. Add and Search Word - Data structure design
https://leetcode.com/problems/add-and-search-word-data-structure-design/description/
挺难！一刷调试了4个小时才AC！理解严重不够！多刷！还不能完整地写出来，再刷！二刷没有AC，对外层for循环和run的更新有了更深的理解。但是对于返回值的判定还是理解不够，再刷！


674. Longest Continuous Increasing Subsequence My SubmissionsBack to Contest
https://leetcode.com/contest/leetcode-weekly-contest-49/problems/longest-continuous-increasing-subsequence/
比较简单，但是这种题我是比较害怕的！还要继续总结！多总结！这才是进步的捷径！

673. Number of Longest Increasing Subsequence
https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/
跟上一题很像！怪不得邓邓把上一道题看成这道题！DP难在算法的理解。看了半天没理解，看了大神的注释之后豁然开朗！一刷AC，但是理解不够，再刷！二刷DEBUG了很久，还是理解不够，心不在焉漏洞百出！再刷！


676. Implement Magic Dictionary
https://leetcode.com/contest/leetcode-weekly-contest-49/problems/implement-magic-dictionary/
一开始想用set或者vector实现，发现效率太低，就改为用字典树实现，字典树实现太难调试了！之后使用set实现，舒服多了！


675. Cut Off Trees for Golf Event
https://leetcode.com/contest/leetcode-weekly-contest-49/problems/cut-off-trees-for-golf-event/
不太难的一道BFS的题目，但是非常繁琐！DEBUG了非常长的时间！对于树而言BFS就是层序遍历，DFS就是后续遍历！代码我到最后都不知道为什么AC了！这份代码非常经典，要拿出来再刷，再总结！


198. House Robber
https://leetcode.com/problems/house-robber/description/
比较简单，DP一刷AC。时间复杂度和空间复杂度都是O(N)，可以将空间复杂度降至O(1)。二刷使用时间复杂度O(N)，空间复杂度为O(1)的DP算法，一次AC。


213. House Robber II
https://leetcode.com/problems/house-robber-ii/description/
一刷没思路，使用大神的DP思路没有对nums的长度为1时的场景进行判断，WA。关键是将该题转化到上面一题。再刷的时候注意理解，思考留出一个house不rob从而破环的合理性。


96. Unique Binary Search Trees
https://leetcode.com/problems/unique-binary-search-trees/description/
DP思路是：将1到n分别作为根，左右两侧都是一个规模更小的子问题，左右两侧结果相乘就是一种情况，枚举所有情况求和即可。一刷AC，二刷没AC，思路不够熟。三刷没思路，看了注释之后AC。四刷使用数组没有初始化WA，应该使用vector。这道题和矩阵相乘的那道题很类似，都是从序列中间取一个元素，分割序列将问题转化为规模更小的子问题，同时分割元素可以是序列中的任意一个元素，这类的递推函数很常见。DP问题的解不仅可以由一个小规模子问题的解得到，还可以由多个甚至所有小规模子问题的解的组合得到。


95. Unique Binary Search Trees II
https://leetcode.com/problems/unique-binary-search-trees-ii/description/
一刷递归AC，算法复杂度？？二刷使用DP，没AC，因为向n-1子树添加右子后没改回原状态。算法复杂度？？三刷使用DP算法AC。四刷使用DP没AC,思路不熟。五刷没AC，n=0边界忘记处理。


300. Longest Increasing Subsequence
https://leetcode.com/problems/longest-increasing-subsequence/#/description
一刷AC，使用patient sort算法，时间复杂度为O(NLOGN)，但是不太理解。二刷一次AC，仍然不太理解。三刷使用java刷，算法使用一维DP，时间复杂度为O(N^2)，效率略低，思路很简单，没AC，要注意重复数字不能计入length。patient sort是专门应对这个题的算法！和95相似，这两个问题的DP算法都有一点弯。四刷一次AC。


647. Palindromic Substrings
https://leetcode.com/problems/palindromic-substrings/description/
一刷使用DP算法AC，时间复杂度和空间复杂度都是O(N^2)。讨论区应该有更好的解法，再刷尝试！讨论区有一个经典的解决字符串中回文子串的算法叫“曼彻斯特算法”，后面要对这种类型进行总结！


416. Partition Equal Subset Sum
https://leetcode.com/problems/partition-equal-subset-sum/description/
一刷没AC，使用时间复杂度为O(N!)的backtracing算法，出现很多CE！最后TLE。也有人说时间复杂度为O(pow(2, N))的！这是个典型的0/1背包问题，0/1背包问题的特点是从一组数中选取某些数达到一定的值。对0/1背包问题的一个很好的解释在下面的链接中：

https://discuss.leetcode.com/topic/67539/0-1-knapsack-detailed-explanation

这一题使用的DP解法对标准0/1背包算法进行了优化，因为题目不需要知道更多的信息，数组开一维就可以。数组开二维也可以，但是比较麻烦，需要更多的初始化，操作！

最优化方法是使用bitset的方法，时间复杂度为O(N)，空间复杂度为O(1)!


139. Word Break
https://leetcode.com/problems/word-break/description/
一刷没思路，使用DP算法一刷AC，时间复杂度O(N^2*M)，空间复杂度O(N),理解起来不难，二刷一次AC。


464. Can I Win
https://leetcode.com/problems/can-i-win/description/
自己没思路，大神思路不太理解。时间复杂度为（dfs导致递归，时间复杂度不会分析），空间复杂度为O(2^N)。一刷dfs的循环次数写错WA。再刷！


467. Unique Substrings in Wraparound String
https://leetcode.com/problems/unique-substrings-in-wraparound-string/description/
大神思路理解不透彻，时间复杂度O(N)，空间复杂度O(1)。一刷理解大神思路的基础上自己实现一次AC。再刷一次！但是这个解法真的是DP吗？


221. Maximal Square
https://leetcode.com/problems/maximal-square/description/
一刷AC，自己的思路和大神的思路相似，我的思路不够简洁，大神使用square的边长表示square。二刷初始化参数写错，RE。
状态方程的理解：(i, j)是square,则(i-1, j-1), (i-1, j),(i, j-1)必定是size的square！如果三者的size不同，则(i, j)取三者最小的加1。时间复杂度和空间复杂度都是O(M*N)。


576. Out of Boundary Paths
https://leetcode.com/problems/out-of-boundary-paths/description/
一刷按照自己的思路初始时没判断参数有可能的异常，RE。思路正确，效率不高，时间复杂度和空间复杂度均为O(N*n*m)。再刷！二刷使用大神的高效解法。


650. 2 Keys Keyboard
https://leetcode.com/problems/2-keys-keyboard/description/
一刷没思路，使用大神的思路AC。大神没有用DP，时间复杂度最好为O(logN),最差O(N)，比DP算法效率高，但是比较难以理解。再刷，注意理解！


377. Combination Sum IV
https://leetcode.com/problems/combination-sum-iv/description/
一刷没思路，DFS都忘了。大神的top-down的DFS超时，加入memo实现DP后，AC。这个题很经典，和之前整理的回溯法有强关联！注意理解DP的含义，我现在仍然不知道这样做是不是就叫做DP。再刷！注意整理！
除了上一种top-down的DP方法，还有一种bottom-up的DP方法，这种方法在我看来更像DP。一刷dp空间分配不够，RE。错误在本地没复现，猜测是因为本地使用伙伴内存管理，dp配额有冗余，而网页后端对内存的检测更严格。
两种方法的空间复杂度都是O(N)，时间复杂度均为O(MN)，top-down方法虽然使用递归，但是这个时间复杂度容易分析。


376. Wiggle Subsequence
https://leetcode.com/problems/wiggle-subsequence/description/
一刷没思路，大神解法集中在贪心和DP两类。贪心算法一刷AC，不好理解，意思是每次选山峰的最高点和最低点，为什么这样就可以保证序列最长？
DP算法一刷初始化变量名写错，WA。再刷！
两种算法的区别和联系是什么？


516. Longest Palindromic Subsequence
https://leetcode.com/problems/longest-palindromic-subsequence/description/
一刷没思路，大神总结了从暴力递归到简化版DP的四种方法，一刷使用暴力递归发现TLE。二刷使用带memo的递归，由于递归深度与字符串长度相同，字符串过长导致栈空间溢出得到MLE。三刷使用DP,一次AC。空间复杂度为O(N^2)，时间复杂度为O(N^2)。四刷使用更高效的DP，一次AC，时间复杂度为O(N^2)，空间复杂度为O(N)。不用再刷，但是可以回顾，这个题目很经典。

暴力递归导致重复计算，于是有了带memo的递归。而随着递归深度增大，栈空间消耗过大，于是有了DP。递归是top-down的思路，而DP则是bottom-up的思路。这道题的关键的状态方程不易理解，需要举个例子，如“bbbab”, 状态方程为("bbbab") = 'b' == 'b' ? 2 + ("bba") ? max("bbba", "bbab")。可以清楚看到"bba"三者都有，而后面两个最大只是("bba") + 1。


322. Coin Change
https://leetcode.com/problems/coin-change/description/
一刷使用贪心剪枝的递归，WA，错在使用贪心算法剪枝并不一定得到最优解！如([10, 25, 30], 50)这个反例，因为问题要找最短的，这相当于提示用BFS。二刷使用一维DP和二维DP，二维DP并不是最优解。三刷使用DFS和BFS，均TLE。

一般面试能碰到的DP可以分为3类，第一类是一维DP（LCS， final_term 第4题），第二类和第三类都是二维DP，其中第二类的下标i和j表示的含义相同，是对称的 (Longest Palindromic Substring, Unique Binary Search Tree, Triangle) ，第三类是下表i和j的含义是不同的，不是对称的 (0-1背包问题，Best Time to Buy and Sell Stock IV)，其实还有三维DP（87. Scramble String）。刷题要精刷，每道题做完都要看discuss区找最优解！

DP问题首先看问题能否降为子问题，如果能将问题分解为规模更小的问题，那就很可能用Buttom-up的DP方法。子问题可能是两个（Climb Stairs, Unique Paths, Minimum Path Sum, Delete and Earn），三个及多个（Coin Change）或者全部更小规模子问题（final term第4道题）。


740. Delete and Earn
https://leetcode.com/contest/weekly-contest-61/problems/delete-and-earn/
DP，可以降为子问题，典型的0-1背包问题。要继续思考，细嚼慢咽还是很有收获的。


494. Target Sum
https://leetcode.com/problems/target-sum/description/
一刷没有好思路，看了大神的解析，将问题转化为一个之前解决过的相似问题，自己使用DFS解决了，但是过程不够顺畅，对于set的计数不能再t=0时直接返回，而应该结果+1。时间复杂度为O(N^2)再刷！二刷使用DP没AC，对vector::resize()理解不对，resize并不会对vector原有的数据进行重置，只会将其截断或者在后端补充，应该先用clear。再刷！

DFS思路：将num分为正集合P和负集合N，于是有下面的推导：
                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
现在问题也就变成了寻求满足条件的P的个数，可以用DFS。官方给每道题都给了答案，而且每道题的答案不止一种，再刷可以重点看看官方答案。


491. Increasing Subsequences
https://leetcode.com/problems/increasing-subsequences/description/
dfs，有点小trick，去重时要遍历之前的所有元素，查看是否有重复，因为题目不允许sort。


304. Range Sum Query 2D - Immutable
https://leetcode.com/problems/range-sum-query-2d-immutable/description/
一刷没有对二维数组的维度进行初始判断，没AC。使用DP，时间复杂度和空间复杂度均为O(M*N)，效率不高，二刷关键是调研更优秀的解法。


474. Ones and Zeroes
https://leetcode.com/problems/ones-and-zeroes/description/
一刷使用暴力DFS，TLE。bitset的使用得到了锻炼，bitset使用set和reset进行赋值，使用test测试位，使用count度量位。二刷使用DP，出了bug，没调通。三刷使用大神的空间复杂度O(M*N)，时间复杂度O(M*N*L)的DP算法，一次AC。大神的思路并不好理解，再刷！注意理解！


375. Guess Number Higher or Lower II
https://leetcode.com/problems/guess-number-higher-or-lower-ii/description/
一刷使用dp思路不对，问题没想清楚，总想着用二分法，事实上二分法的结果并非最优！二刷使用大神的bottom-up的DP，没有一次AC，对DP的更新过程理解不够，再刷，注意理解。


638. Shopping Offers
https://leetcode.com/problems/shopping-offers/description/
一刷使用自己设计的DP方法，WA。二刷使用带memo的dfs，这是top-down的dp，但是我更熟悉bottom-up的dp。由于把变量k写成key（这也是变量名设计问题），一直WA，debug很久。思路比较清晰，我自己两个思路都想明白了，但是手生。再刷！


690. Employee Importance
https://leetcode.com/problems/employee-importance/description/
一刷使用DFS暴力递归AC。效率低，时间复杂度为O(LN)，空间复杂度为O(L)，L为下属员工总个数（包括非直接下属），N为员工总数。再刷尝试高效解法。


513. Find Bottom Left Tree Value
https://leetcode.com/problems/find-bottom-left-tree-value/description/
一刷使用DFS暴力递归AC，效率低。时、空间复杂度O(L^2)，因为递归深度为L，查深度和查最左下元素都要递归到最底层。再刷要使用高效解法。二刷使用大神的DFS解法，不太理解，再刷！


693. Binary Number with Alternating Bits
https://leetcode.com/problems/binary-number-with-alternating-bits/description/
一刷没AC，忘记更新ex。时间复杂度为O(log N)，空间复杂度为O(1)。没有再刷的必要。


691. Stickers to Spell Word
https://leetcode.com/problems/stickers-to-spell-word/description/
一刷没思路，套用大神的思路是带memo的DFS，思路很清晰，一刷AC。时、空间复杂度为O(N)，递归深度也是N。手生，再刷。


695. Max Area of Island
https://leetcode.com/problems/max-area-of-island/description/
一刷AC，关键思想是算法核心使用dfs,利用queue存储中间结果，原地更改数组。时间复杂度为O(M*N)，空间复杂度为O(1)。


733. Flood Fill
https://leetcode.com/contest/weekly-contest-60/problems/flood-fill/
dfs, 注意将访问过的节点设置为特殊字符，然后再变回来，防止死循环。


694. Number of Distinct Islands
https://leetcode.com/contest/leetcode-weekly-contest-53/problems/number-of-distinct-islands/
一刷没有想到怎么表示多个岛之间的“translation”的关系，题意不太理解，跟上题很像，只需要用set记录编码之后的island的所有node，最后返回set的长度即可。还学到了访问matrix一个元素四周邻居的更省空间的方式，数组bias设置为[1, 0, -1, 0, 1]即可，每次访问row的bias为bias[i],column的bias为bias[i + 1]，非常巧妙！这个题目对于非付费用户依据封锁了，尽快再刷一次。


496. Next Greater Element I
https://leetcode.com/problems/next-greater-element-i/description/
一刷没思路，借鉴大神基于stack的思路AC。思路很奇妙，还需深入理解。二刷AC，简化了代码。


503. Next Greater Element II
https://leetcode.com/problems/next-greater-element-ii/description/
一刷使用和上题相似的思路，没想清楚，WA。本题中有重复元素，stack和map都要保存index，和上题的区别在于要进行两次遍历，算法效率还可以继续提升。时间和空间复杂度为O(N)。再刷。


144. Binary Tree Preorder Traversal
https://leetcode.com/problems/binary-tree-preorder-traversal/description/
二叉树先序遍历，一刷递归AC。二刷使用非递归算法一次AC，注意入栈的时先对右子树入栈，再对左子树入栈，从而保证左子树优先访问。


341. Flatten Nested List Iterator
https://leetcode.com/problems/flatten-nested-list-iterator/description/
一刷思路不对，使用大神的思路一刷没有AC，跟我的思路相似。再刷，深入理解大神的算法。


173. Binary Search Tree Iterator
https://leetcode.com/problems/binary-search-tree-iterator/description/
一刷按照和上题相似的思路，初始化时，遍历查找最左节点没有更新root，导致内存溢出。时间复杂度为O(N)，空间复杂度为O(H)。二刷一次AC，精简了代码。


394. Decode String
https://leetcode.com/problems/decode-string/description/
一刷使用自己的算法WA。二刷使用大神的算法AC，使用两个stack分别存放“[x]”出现时之前的num和应该加到num * "[x]"之前的string，每个元素只表示一层，跟上层无关。思路理解了，但是还不熟，再刷。三刷使用递归算法，运行时间少于非递归算法，没有AC，思路不是很清楚，再刷。


331. Verify Preorder Serialization of a Binary Tree
https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/
一刷使用自己的算法，没AC，看了讨论区，有大佬和我的算法相同，稍微修改了自己的代码AC。注意考虑两点，数的长度不止为1，中间过程如果stack为空，直接返回false即可。再刷一次。


103. Binary Tree Zigzag Level Order Traversal
https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/
BFS，deque。


150. Evaluate Reverse Polish Notation
https://leetcode.com/problems/evaluate-reverse-polish-notation/description/
一刷AC，注意先出栈的第二个操作数，后出栈的是第一个操作数。


456. 132 Pattern
https://leetcode.com/problems/132-pattern/description/
一刷没思路，使用大神的算法，一次AC，但是理解不透彻。关键不太理解为什么要用while循环，是为了使用更大的中间值？再刷。


402. Remove K Digits
https://leetcode.com/problems/remove-k-digits/description/
一刷没思路，使用大神的算法，因为没注意循环过程中k会更新导致WA，debug很久。再刷！


636. Exclusive Time of Functions
https://leetcode.com/problems/exclusive-time-of-functions/description/
一刷没有想清楚怎么将中间退栈时得到的中间时间段存下来WA。二刷使用大神的算法，和我的算法相似，但是使用了stringstream，并且自己设计了新的struct，效率可能会受影响，但是非常清晰。中间没对stack判空RE。再刷。


215. Kth Largest Element in an Array
https://leetcode.com/problems/kth-largest-element-in-an-array/description/
一刷使用快排AC，快排的partition函数不止可以用挖坑填坑的方式写，还可以按照这个算法写，但是有bug，再刷！


347. Top K Frequent Elements
https://leetcode.com/problems/top-k-frequent-elements/description/
一刷使用map统计频率，按频率倒排，使用lambda表达式简化代码，O(NlogN)。二刷使用堆排，O(NlogN)。三刷使用快搜，O(N)。四刷使用priority_queue，O(NlogN),其实就是完全堆排。五刷简化四刷使用的方法，不再使用函数对象。五刷使用桶排序，bucket_size为1，将每个可能的频率都视为一个bucket，O(N)。建堆时间复杂度证明：http://blog.csdn.net/anonymalias/article/details/8807895




692. Top K Frequent Words
https://leetcode.com/problems/top-k-frequent-words/description/
一刷暴力解决，AC。二刷使用基于heap sort的方法，WA。有一点不太理解，为什么最后的结果的顺序和我想的相反？


355. Design Twitter
https://leetcode.com/problems/design-twitter/description/
一刷使用基于堆排序的方法AC，效率并不是很高。明白了为什么有时候会和结果反序，这是因为我写的堆排序的结果是升序，而这种题目一般要求要降序输出结果。


490. Maze
锁定了，写不了。
但是比较简单，至少有两种写法。
一是使用visited，而是将访问过的区域设置为阻隔，有个非常相似的题目，但是我给忘了。


110. Balanced Binary Tree
https://leetcode.com/problems/balanced-binary-tree/description/
可以使用DFS和BFS，一刷使用BFS，效率非常低。二刷使用优化过的DFS，快了很多，用depth=-1表示不满足平衡性，从而实现短路计算，效率很高。三刷使用没有优化的递归算法，计算树深大量重复。四刷使用带memo的recursion，效率不如用depth=-1表示不平衡的算法高。


373. Find K Pairs with Smallest Sums
https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/
一刷基于heap来做的，一次AC。效率并不高，要先把所有可能的组合都存下了，然后再用堆排序找出前k个，再刷要注意提升效率。


659. Split Array into Consecutive Subsequences
https://leetcode.com/problems/split-array-into-consecutive-subsequences/description/
一刷没思路，找了一个比较容易理解的思路看了半天！一刷没有写temp[i]--，思路很好，但是还有继续理解！时间和空间复杂度均为O(N)。


100. Same Tree
https://leetcode.com/problems/same-tree/description/
递归，一次AC。


98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/description/
递归使用min和max限定子树范围。非递归利用BST的中序遍历一定是递增序列的性质。


230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/
一刷使用基于非递归中序遍历二叉树的方法AC。


113. Path Sum II
https://leetcode.com/problems/path-sum-ii/description/
一刷递归没考虑到节点的值可以使负的，自以为地剪枝WA，去掉之后AC。再来一次。


200. Number of Islands
https://leetcode.com/problems/number-of-islands/description/
一刷递归没AC，小错误不断，再来一次。效率不高，再想想怎么提高效率。


473. Matchsticks to Square
https://leetcode.com/problems/matchsticks-to-square/description/
一刷递归，效率低，有大量重复计算，自己的逻辑不清晰，TLE。二刷发现大神的DFS思路和我一致，按照大神的思路改完之后效率提高很多，但是仍然有优化的空间，重复计算问题并没有完全解决。


37. Sudoku Solver
https://leetcode.com/problems/sudoku-solver/description/
一刷使用DFS能AC，不太理解后2个return值设置的含义。


102. Binary Tree Level Order Traversal
https://leetcode.com/problems/binary-tree-level-order-traversal/description/
双queue实现bfs。


127. Word Ladder
https://leetcode.com/problems/word-ladder/description/
双queue实现BFS。


515. Find Largest Value in Each Tree Row
https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/
BFS，一刷AC。


199. Binary Tree Right Side View
https://leetcode.com/problems/binary-tree-right-side-view/description/
BFS，一刷AC。


130. Surrounded Regions
https://leetcode.com/problems/surrounded-regions/description/
dfs。不能从所有单元格出发进行dfs或者bfs，而是从四条边界出发使用dfs或者bfs即可。、


301. Remove Invalid Parentheses
https://leetcode.com/problems/remove-invalid-parentheses/description/
一刷使用DFS,注意从左向右走，分三种情况考虑，左括号，右括号和字母。二刷使用BFS，没有更新max导致WA。


297. Serialize and Deserialize Binary Tree
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/
一刷使用基于先序遍历的递归方法没AC，没有将val转为string。思路就是先用pre_order遍历，生成字符串，再按pre_order顺序还原二叉树。


99. Recover Binary Search Tree
https://leetcode.com/problems/recover-binary-search-tree/description/
一刷使用递归中序遍历的方式没有AC，不理解first更新为pre和second更新为root的过程。再刷！


87. Scramble String
https://leetcode.com/problems/scramble-string/description/
一刷递归TLE，没有先sort判断字符串是否相同减少递归深度。二刷使用sort之后AC，不是很理解思路，再刷。三刷使用java刷AC。四刷使用DP，思路和递归差别不大，边界参数错了好几个WA。使用if进行短路优化时间比不用短路优化还要长，猜是因为if破坏了流水线结构。


546. Remove Boxes
https://leetcode.com/problems/remove-boxes/description/
一刷递归思路有漏洞，二刷使用DFS，代码看了很久才理解，主要是k参数表示的是起始元素（第i个元素）的重复次数。数据的删除过程很精妙，将两个相同元素之间的子序列进行递归，起始元素就是k记录的重复元素。参数设置出错WA。三刷使用DP参数设置错了好多WA，代码看了好久才明白，看了  https://discuss.leetcode.com/topic/84687/java-top-down-and-bottom-up-dp-solutions 链接里的解释，写的非常详细，非常感谢！


452. Minimum Number of Arrows to Burst Balloons
https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/
贪心算法，自己陷入了一个有多种解需要遍历的怪圈，其实不需要。按终点大小排序后直接从直径终点射出就可以了！再刷！我的思路是每次找到重合最多的坐标点，刺破覆盖该位置的所有气球。重复以上步骤直到气球全部被刺破，这个方法一定奏效，但是复杂度极高。为什么贪心算法能work呢？


435. Non-overlapping Intervals
https://leetcode.com/problems/non-overlapping-intervals/description/
与452非常相似，但是并没有想到怎么做，看Wikipedia（https://en.wikipedia.org/wiki/Interval_scheduling#Interval_Scheduling_Maximization）也没看懂，真菜！对于贪心还是不太理解，再刷。


621. Task Scheduler
https://leetcode.com/problems/task-scheduler/description/
一刷没思路，讨论区使用的算法没有看出什么门道，就是找出最频繁的字母，按公式给出结果。公式是：循环体size * 循环次数(频繁字母频率-1) + 剩余的频繁字母个数。公式有特例如3个A，3个B，3个C，1个D，n=2时就不对，此时res=tasks.size()。再刷！


122. Best Time to Buy and Sell Stock II
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/
一刷使用贪心算法，不涨就买，涨就卖。理解还是不够深入。


714. Best Time to Buy and Sell Stock with Transaction Fee
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/
一刷使用自己设计的贪心算法：先买，涨了就卖，这样是不对的！[1,3,7,5,10,3]这个case就不对。二刷使用s0和s1分别记录两种状态，这是有限状态自动机的概念，s0是手里没有股票的收益，s1是手里有一支股票的收益，在两个状态之间切换，和309很像。


309. Best Time to Buy and Sell Stock with Cooldown
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
一刷没思路，使用基于有限状态机的DP，一刷AC，时间复杂度和空间复杂度均为O(N)。s0,s1,s2三个状态分别表示最后一个操作为rest, buy, sell的当天maxprofit。再刷！


649. Dota2 Senate
https://leetcode.com/problems/dota2-senate/description/
一刷使用自己设计的贪心算法，分别使用2个参数(count, skip)为双方计数，WA。总计81个case，卡在第78个。分析发现自己对于题目理解有问题，被ban掉的人没有投票权，拥有投票权的人均属于同一方才算赢，这是一个多轮次的游戏。二刷基于queue对游戏进行模拟，思路是一方将另一方ban掉，靠前的那一方ban，靠后的那一方被ban，而且ban的那一方经过这一轮之后下一轮仍然可以投票，所以要将这个数加上N之后放到队列末尾。二刷AC。


134. Gas Station
https://leetcode.com/problems/gas-station/description/
一刷贪心算法没写好，WA。注意遍历i过程中，用j更新i时更新到j - 1即可,for循环最后还要进行i++。效率不够高，时间空间复杂度都是O(N)。


179. Largest Number
https://leetcode.com/problems/largest-number/description/
一刷基于sort做，AC。可以直接对数字排序，然后逐个加进来。要更深入地理解为什么这样能work！


324. Wiggle Sort II
https://leetcode.com/problems/wiggle-sort-ii/description/
一刷使用笨方法，没AC，完全招架不住Follow up。再刷。


225. Implement Stack using Queues
https://leetcode.com/problems/implement-stack-using-queues/submissions/1
用deque很简单。一刷没AC，pop函数和普通的stack的pop不同，要返回栈顶元素。


42. Trapping Rain Water
https://leetcode.com/problems/trapping-rain-water/description/
递减栈，出栈情况下不用入栈，WA。需要深入理解。


739. Daily Temperatures
https://leetcode.com/contest/weekly-contest-61/problems/daily-temperatures/
非严格递减栈，比较简单，但是还是debug很久！注意存的是index，注意循环可以用for也可以用while，这题用while比较好！


735. Asteroid Collision
https://leetcode.com/contest/weekly-contest-60/problems/asteroid-collision/
利用stack的特性，注意分类，debug很久！


296. Best Meeting Point
这是一道锁定题。横轴纵轴互不影响，可以将两个维度直接拆开，每个维度排序之后去掉单个的中间节点，加上剩余配对的节点直接的距离即可。一刷没AC，计算sum的时候横轴和纵轴分到两个循环了，在一个循环就可以了，因为长度都一样，注意end初始应该设为posList.size() - 1。


164. Maximum Gap
https://leetcode.com/problems/maximum-gap/description/
一刷使用暴力算法，先sort然后遍历，O(NlogN)的时间复杂度。题目要求O(N)的时间和空间复杂度，桶排序可以满足要求。二刷使用桶排序算法，时间和空间复杂度都是O(N)。由于bucket size设置不当（应该再加1），导致运行时出现除零操作RE。bucket size并不是非常重要的参数，bucket的个数也不需要非常严格，但是一定要保证大于需要的桶的个数。


23. Merge k Sorted Lists
https://leetcode.com/problems/merge-k-sorted-lists/description/
优先级队列，时间复杂度为O(NKlogK)，一刷没AC。头条喜欢考！priority_queue的构造函数中第三个参数不可以使用lambda表达式。


239. Sliding Window Maximum
https://leetcode.com/problems/sliding-window-maximum/description/
一刷使用java优先级队列（因为c++中的优先级队列没有remove接口）没有判空CE，时间复杂度为O(NlogK)，时间复杂度不够好，最好的算法是递归。


295. Find Median from Data Stream
https://leetcode.com/problems/find-median-from-data-stream/description/
分别使用小根堆和大根堆存储较大的部分和较小的部分，控制大根堆的size = 小根堆的size或者小根堆的size + 1。一刷没处理好插入元素的大小和大根堆小根堆的size的限制关系，WA。


332. Reconstruct Itinerary
https://leetcode.com/problems/reconstruct-itinerary/description/
dfs和heap结合，时间复杂度？思想是path先添加无路可走的节点，使用链表的头插法。c++的list数据结构基于链表实现，接口很多，非常方便，相当于java中的LinkedList。分别使用c++和java刷过，但是都没有一次AC。三刷忘记了基于heap的方法，使用纯DFS加排序。两种算法的时间复杂度在搜索解空间时有较大区别，还需要认真分析。


290. Word Pattern
https://leetcode.com/problems/word-pattern/description/
双map，一次AC。


291. Word Pattern II
https://www.programcreek.com/2014/07/leetcode-word-pattern-ii-java/
双map和dfs结合，一刷没AC，strStart应该更新为i + 1而不是i。


734. Sentence Similarity
https://leetcode.com/contest/weekly-contest-60/problems/sentence-similarity/
map，没理解题意，sentence相似要求每个位置的word都相似！第一次用python刷题，比c++快多了，在数据结构涉及set，string等结构时，python非常方便。


525. Contiguous Array
https://leetcode.com/problems/contiguous-array/description/
核心公式diff[i, j] = diff[0,j] - diff[0,i]，diff表示1比0多的个数，数组的一小段的diff等于整个数组的起始位置到段结尾的diff减去全数组起始位置到段起始的diff。当两个diff相等，表示中间的小段0和1的个数相同，更新结果。一刷没AC，注意处理空数组（diff要多加一个空位，map也要！）。


76. Minimum Window Substring
https://leetcode.com/problems/minimum-window-substring/description/
双指针，难以理解。一刷Debug很久。注意前指针和后指针的更新以及极限情况（字符串为空或者长度为1）。start和end分别表示窗口的起始和末尾，window这个map就是start到end这段子串的符号及频数。二刷书写错误没AC。


207. Course Schedule
https://leetcode.com/problems/course-schedule/description/
graph拓扑排序，算法复杂度有点高，可继续优化！一次AC。


210. Course Schedule II
https://leetcode.com/problems/course-schedule-ii/description/
graph拓扑排序，和上一道比仅仅是输出结果有变化。


133. Clone Graph
https://leetcode.com/problems/clone-graph/description/
graph的dfs, 注意图中可能有环。


269. Alien Dictionary
http://blog.csdn.net/qq508618087/article/details/50981000
这是一道有锁题，graph的拓扑排序。


310. Minimum Height Trees
https://leetcode.com/problems/minimum-height-trees/description/
graph的拓扑排序。


399. Evaluate Division
https://leetcode.com/problems/evaluate-division/description/
图的dfs,一刷虽然有些typo，但是一次AC！我感觉自己刷题真的变厉害了，套路题我不怕了！


738. Monotone Increasing Digits
https://leetcode.com/contest/weekly-contest-61/problems/monotone-increasing-digits/
数学题，没认真想，思路不好，不要怕开空间！


740. Delete and Earn
https://leetcode.com/contest/weekly-contest-61/problems/delete-and-earn/
DP，可以降为子问题，典型的0-1背包问题。要继续思考，细嚼慢咽还是很有收获的。


393. UTF-8 Validation
https://leetcode.com/problems/utf-8-validation/description/
dfs和位运算，注意位运算的优先级没有判断符号优先级高！位运算的优先级很低！


617. Merge Two Binary Trees
https://leetcode.com/problems/merge-two-binary-trees/description/
简单递归


637. Average of Levels in Binary Tree
https://leetcode.com/problems/average-of-levels-in-binary-tree/description/
双queue层序遍历


653. Two Sum IV - Input is a BST
https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/
递归，BST查找，想复杂了！


538. Convert BST to Greater Tree
https://leetcode.com/problems/convert-bst-to-greater-tree/description/
一开始思路不好，只想着记录父节点，导致重复计算，要再想一下为什么！使用sum记录当前访问的最大值，是最吼的，逆先序遍历即可。


563. Binary Tree Tilt
https://leetcode.com/problems/binary-tree-tilt/description/
BST的递归，自己的思路RE，想破头没想明白，大佬的思路比我的简洁，只用了一个递归！我的用了两个递归！


572. Subtree of Another Tree
https://leetcode.com/problems/subtree-of-another-tree/description/
两个递归，效率略低。


437. Path Sum III
https://leetcode.com/problems/path-sum-iii/description/
双递归，注意空节点的处理。不能靠子节点判断父节点的值的情况，因为子节点有两个，这样容易导致重复。


501. Find Mode in Binary Search Tree
https://leetcode.com/problems/find-mode-in-binary-search-tree/description/
双递归，子递归设计要注意Mode中的数字对应节点不一定都连着，利用BST的性质！


687. Longest Univalue Path
https://leetcode.com/problems/longest-univalue-path/description/
双递归。


654. Maximum Binary Tree
https://leetcode.com/problems/maximum-binary-tree/description/
树的递归。


145. Binary Tree Postorder Traversal
https://leetcode.com/problems/binary-tree-postorder-traversal/description/
二叉树后续遍历递归与非递归实现。多做是有用的，非常有用，做这个题的时候深有体会！


655. Print Binary Tree
https://leetcode.com/problems/print-binary-tree/description/
合并左右子树的时候思路要清晰，分情况，不是两边一直用空串填充，而是每个元素两侧都使用空串填充！一步步简化代码，对容器的insert函数用熟了！


623. Add One Row to Tree
https://leetcode.com/problems/add-one-row-to-tree/description/
树的层序遍历（双queue），注意要保存更上一层的节点，添加子树时不必考虑子树是否为空！


337. House Robber III
https://leetcode.com/problems/house-robber-iii/description/
递归，有点0-1背包的意思。


662. Maximum Width of Binary Tree
https://leetcode.com/problems/maximum-width-of-binary-tree/description/
一刷使用BFS，当树的高度过大时，内存溢出。二刷基于BFS，利用满二叉树的性质（子节点和父节点index之间的关系，左子index = 父节点index * 2， 右子index = 父节点index * 2 + 1）AC。


129. Sum Root to Leaf Numbers
https://leetcode.com/problems/sum-root-to-leaf-numbers/description/
dfs，遇到叶子节点就把num(表示path)加到res上。如果follow up将节点的数只有1位的限制去掉，可以使用vector表示path。


450. Delete Node in a BST
https://leetcode.com/problems/delete-node-in-a-bst/description/
好题！删除BST中的节点，上课讲过，自己做还是废了不少时间。递归删除节点，找到节点后分情况讨论，找左子树的最大值或者右子树的最小值作为新的根的值，并删除原节点，findAndDelete函数要注意删除节点不能直接将父节点的右子树设为NULL，要设为删除节点的左子树！


116. Populating Next Right Pointers in Each Node
https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/
双queue的BFS不是最优解，利用next指针空间复杂度可以降到O(1)。


117. Populating Next Right Pointers in Each Node II
https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/
与116类似，均可以用双queue层序遍历的方式做，但是不是最优解，最优解是使用next指针优化层序遍历的空间复杂度,使用pre记录前一个节点，也用pre判断是否结束循环。


236. Lowest Common Ancestor of a Binary Tree
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
LCA，非常经典，一次AC。O(N)时间复杂度，递归找path，选出最后一个相同节点。


297. Serialize and Deserialize Binary Tree
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/
树的序列化与反序列化，非常经典！先序遍历的递归。


449. Serialize and Deserialize BST
https://leetcode.com/problems/serialize-and-deserialize-bst/description/
BST的序列化与反序列化，和上题使用完全相同的思路AC，应该可以结合BST的特征进行简化！


652. Find Duplicate Subtrees
https://leetcode.com/problems/find-duplicate-subtrees/description/
利用树的遍历先进行序列化，在序列化过程中将序列化结果和根节点对应起来，注意树的序列化结果要有唯一性，必须加入额外信息：如两侧加括号。


752. Open the Lock
https://leetcode.com/contest/weekly-contest-64/problems/open-the-lock/
BFS，很简单，比赛的时候网站报的出问题case不对，出问题的原因是没有对"0000"这一状态进行检测就加入了队列，但是网站上给的提示case不是这个。感觉DP也能做，但是想不到能从小到大填空的思路。


747. Largest Number Greater Than Twice of Others
https://leetcode.com/contest/weekly-contest-64/problems/largest-number-greater-than-twice-of-others/
数组最大值，简单题


284. Peeking Iterator
https://leetcode.com/problems/peeking-iterator/description/
系统设计题，考的是拷贝构造函数的应用。


208. Implement Trie (Prefix Tree)
https://leetcode.com/problems/implement-trie-prefix-tree/description/
系统设计题，实现前缀树。注意要用c - 'a'而不是直接用c来索引后继节点！


648. Replace Words
https://leetcode.com/problems/replace-words/description/
Trie


307. Range Sum Query - Mutable
https://leetcode.com/problems/range-sum-query-mutable/description/
一刷使用暴力解法AC，时间复杂度为O(N)。用线段树和二分索引树做时间复杂度可以降到O(log N)。


530. Minimum Absolute Difference in BST
https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/
一刷递归一次AC。


729. My Calendar I
https://leetcode.com/problems/my-calendar-i/description/
线段交集，感觉跟线段树或者二分索引书有关，不清楚！要继续思考，一刷AC。


731. My Calendar II
https://leetcode.com/problems/my-calendar-ii/description/
这是一道什么类型的题？还有什么其他方法？这类interval的题目还是比较多的。一刷使用逐一重叠并记录的方法。



220. Contains Duplicate III
https://leetcode.com/problems/contains-duplicate-iii/description/
一刷暴力法，O(NK)的时间复杂度，TLE。二刷使用基于bucket的方法AC。


382. Linked List Random Node
https://leetcode.com/problems/linked-list-random-node/description/
概率题，ACM校赛考过类似题型。


398. Random Pick Index
https://leetcode.com/problems/random-pick-index/description/
同上


560. Subarray Sum Equals K
https://leetcode.com/problems/subarray-sum-equals-k/description/
一刷使用二维DP内存超了，改为一维DP之后AC，这两种方法都是O(N^2)时间复杂度，空间复杂度一个为O(N^2)，一个为O(N)。二刷三刷用map存储累积和，map的查找替换了vector的查找，时间复杂度从O(N^2)降到了O(N)。仍然不太理解初始时"m[0]=1"的设置！


760. Find Anagram Mappings
https://leetcode.com/contest/weekly-contest-66/problems/find-anagram-mappings/
map，key为元素值，value为vector的iterator。


758. Bold Words in String
https://leetcode.com/contest/weekly-contest-66/problems/bold-words-in-string/
转化为合并interval


759. Employee Free Time
https://leetcode.com/contest/weekly-contest-66/problems/employee-free-time/
同上题，转化为合并interval。


2018.1.10.1 Eat Cheese I
房间里有多块奶酪(x,y)，小老鼠一开始在(0,0)，问小老鼠吃掉所有奶酪要走的最短距离。
dfs + 剪枝。

2018.1.10.2 Eat Cheese II
房间表示为二维数组, 元素值0，1，2分别不可走，可走，奶酪。小老鼠从左上起点出发，吃掉所有奶酪，到达右下终点需要的最短路径。
dfs + bfs。


2018.1.11.1 Round Robin
轮询调度，带权重的轮询调度
最大公约数、多个数的最大公约数、轮询调度


28. Implement strStr()
https://leetcode.com/problems/implement-strstr/description/
暴力匹配和KMP算法，KMP算法关键在于求解next数组。求解next数组和模式匹配过程相似，只是求解过程需要修改next数组。


762. Prime Number of Set Bits in Binary Representation
给定一个范围，判断范围内的每个数的二进制表示中1的个数是否为质数
bitset


763. Partition Labels
将仅含有小写字母的字符串，要求划分后子串尽可能多而且每个字母最多出现在一个划分中。
DFS超时，贪心AC。


764. Largest Plus Sign
判断仅含有0和1的矩阵中，1的位置能够组成的最大“十字架”的形状大小。
DP。


65. Valid Number
https://leetcode.com/problems/valid-number/description/
正则表达式，注意trim之后再进行正则表达式匹配。


70. Climbing Stairs
https://leetcode.com/problems/climbing-stairs/description/
DP和递归，递归超时，可以使用迭代替换递归


88. Merge Sorted Array
https://leetcode.com/problems/merge-sorted-array/description/
合并两个排好序的数组。我用了堆，用了temp，空间复杂度过高。最优解是将较长的数组扩充，然后倒着插入，思路类似快排，挖坑填坑。


125. Valid Palindrome
https://leetcode.com/problems/valid-palindrome/description/
字符相关API如：isdigit,isalpha,isalnum,isupper,islower要用熟。


4. Median of Two Sorted Arrays
https://leetcode.com/problems/median-of-two-sorted-arrays/description/
二分查找。查找两个有序数组总的中位数，要求O(log(m+n))的时间复杂度。基于归并排序的方式O(m+n)的复杂度，基于递归的二分查找可以达到复杂度要求。


10. Regular Expression Matching
https://leetcode.com/problems/regular-expression-matching/description/
正则表达式匹配，频率超高！同频的还有四则运算表达式的计算，前、中、后缀表达式切换和运算！
递归方法分char和‘.’，之后在内部讨论后面是否有'*'。DP考虑是否为'*'，是'*'分不重复和重复重复，重复时'x*x'只需判断s把x去掉之后的情况，不是'*'可以归于一类。


44. Wildcard Matching
https://leetcode.com/problems/wildcard-matching/description/
递归超时，DP可以AC。和10非常相似。还有更简单的方法及双指针法。
https://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html



766. Toeplitz Matrix
查看矩阵的每条斜向下对角线上的元素是否相同


767. Reorganize String
将字符串重排，要求相邻的两个字母不同，dfs超时，应该用优先级队列。


769. Max Chunks To Make Sorted (ver. 1)
给定数组为下标的一种排列，将数组进行partition，要求每个子数组排序后整个数组也有序，给出合法的partition后最多的子数组个数。


768. Max Chunks to Make Sorted (ver. 2)
与上题不同的地方在于数组中元素可以有重复。














