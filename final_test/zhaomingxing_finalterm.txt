// 第1题， BFS，逐层加长当前结果，并作为新的结果

struct TreeNode{
    int  val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x), left(NULL),right(NULL){};
};

void printChristmasTree(TreeNode* Root) {
    if (!Root) return;
    vector<vector<string>> res;
    queue<TreeNode* > q, next;
    q.push(Root);
    vector<string> v, next_v;
    v.push_back(to_string(Root->val));
    res.push_back(v);
    while (!q.empty()) {
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            if (cur->left) {
                next_v.push_back(to_string(cur->left->val));
                next.push(cur->left);
                next_v.push_back(" ");
                next.push(cur->right);
                next_v.push_back(to_string(cur->right->val));
            }
        }
        if (next_v.size() > 0) {
            vector<vector<string>> new_res;
            for (auto iter = res.begin(); iter!= res.end(); iter++) {
                vector<string> s(iter->size() * 2 + 1, " ");
                for (int i = 0; i < iter->size(); i++) {
                    s[i * 2 + 1] = iter->at(i);
                }
                new_res.push_back(s);
            }
            new_res.push_back(next_v);
            res = new_res;
            next_v.clear();
            swap(q, next);
        } else {
            for (auto v : res) {
                for (auto s : v) {
                    cout << s;
                }
                cout << endl;
            }
            return;
        }
    }
    
}



// 第2题， BFS
struct node {
    int val;
    node* next;
    node* child;
    node(int x): val(x), next(NULL), child(NULL) {};
};

node* flattenList(struct node *head){
    if (!head->next) return head;
    queue<node*> q, next;
    q.push(head->next);
    while (!q.empty()) {
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            node* pre = NULL, *tmp = cur;
            while (tmp) {
                if (tmp->child) {
                    q.push(tmp->child);
                    tmp->child = NULL; // 断开当前原始父节点到子女的链接
                }
                pre = tmp;
                tmp = tmp->next;
            }
            if (q.empty()) {
                // 没有兄弟看是否有下一层，如果没有，就返回，有的话就链接到后面
                if (!next.empty()) {
                    pre->next = next.front();
                }
                else return head;
            } else {
                // 有兄弟则链接到后面
                pre->next = q.front();
            }
        }
        swap(q, next);
    }
    return head;
}



// 第3道

bool my_compare(pair<double, double> l, pair<double, double> r) {
    return l.first < r.first;
}

// 暴力解法，逐步增大k，查看前k个area是否能够组成0-1区间
// 题目中的原型好像不太对，这里我稍作改动。
int minimumRaindrops (vector<pair<double, double>> raindrops){
    int n = raindrops.size();
    if (n == 0) return -1;
    for (int i = 1; i <= n; i++) {
        vector<pair<double, double>> tmp(raindrops.begin(), raindrops.begin() + i);
        sort(tmp.begin(), tmp.end(), my_compare);
        int b = tmp[0].first, e = tmp[0].second;
        if (b != 0) continue;
        for (auto p : tmp) {
            if (p.first <= e) {
                e = p.second;
                if (e == 1) return i;
            } else break;
        }
    }
    return -1;
}



// 第4题


// dfs查看当前str能否由dict中的单词组成
bool canContruct(string& s, vector<string>& dict, int start) {
    if (s.size() == start) return false;
    for (int i = start; i < s.size(); i++) {
        if (find(dict.begin(), dict.end(), s.substr(start, i - start + 1)) != dict.end() && canContruct(s, dict, i + 1)) return true;
    }
    return false;
}

// DFS, 本步查看当前str能否由dict单词组成，如果可以返回0，如果不可以，遍历str，str变为除去一个字符之后的str，递归，如果都不行，返回-1
int removeCharacters(string str, vector<string>& dict){
    if (str.size() == 0) return 0;
    if (canContruct(str, dict, 0)) return 0;
    for (int i = 0; i < str.size(); i++) {
        string tmp = str.substr(0, i) + str.substr(i + 1, str.size() - i - 1);
        int r = removeCharacters(tmp, dict)
        if (r != -1) return r + 1;
    }
    return -1;
}








